using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.IO;

namespace CA_ProjectEuler
{
    public class Problems
    {
        #region Problem 1
        /// <summary>
        /// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        /// Find the sum of all the multiples of 3 or 5 below 1000.
        /// </summary>
        /// <returns></returns>
        public static int Problem1() => Enumerable.Range(1, 1000).Where(n => n % 3 == 0 || n % 5 == 0).Sum();
        #endregion

        #region Problem 2

        /// <summary>
        /// Each new term in the Fibonacci sequence is generated by adding the previous two terms.By starting with 1 and 2, the first 10 terms will be:
        /// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        /// 
        /// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
        /// </summary>
        /// <returns></returns>
        public static long Problem2() => GetFibonacciValue_UntilMaxResult(4000000).Where(p => p % 2 == 0).Sum();

        static List<long> GetFibonacciValue_UntilMaxResult(long maxResult)
        {
            List<long> retFibo = new List<long>();

            for (int i = 0; true; i++)
            {
                long fTMP = Extra.GetFibonacciValue_ByStep(i);

                if (fTMP < maxResult)
                {
                    retFibo.Add(fTMP);
                }
                else
                {
                    break;
                }
            }

            return retFibo;
        }

        #endregion

        #region Problem 3

        /// <summary>
        /// The prime factors of 13195 are 5, 7, 13 and 29.
        /// 
        /// What is the largest prime factor of the number 600851475143?
        /// </summary>
        /// <returns></returns>
        public static long Problem3() => 600851475143.GetPrimesFactors().Last();
        #endregion

        #region Problem 4

        /// <summary>
        /// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
        /// 
        /// Find the largest palindrome made from the product of two 3-digit numbers.
        /// </summary>
        /// <returns></returns>
        public static int Problem4()
        {
            int MaxPal = MaxPalindromic();

            return MaxPal;
        }

        private static int MaxPalindromic()
        {
            int result = 0;

            for (int i = 100; i <= 999; i++)
            {
                for (int ii = i; ii <= 999; ii++)
                {
                    int mult = i * ii;

                    if (IsPalindromicNumber(mult))
                    {
                        result = Math.Max(mult, result);
                    }
                }
            }

            return result;
        }

        public static bool IsPalindromicNumber(int number)
        {
            string numberStr = number.ToString();
            bool isEven = numberStr.Length % 2 != 0;
            int middle = isEven ? numberStr.Length / 2 : (numberStr.Length - 1) / 2;

            string first = numberStr.Substring(0, middle);
            string last = new string(numberStr.Reverse().ToArray()).Substring(0, middle);

            return first.Equals(last);
        }

        #endregion

        #region Problem 5
        /// <summary>
        /// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
        ///
        /// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
        /// </summary>
        /// <returns></returns>
        public static BigInteger Problem5()
        {
            for (BigInteger i = 20; true; i += 3)
            {
                if (EvenlyDivisibleBy(i, 20))
                {
                    return i;
                }
            }
        }

        static bool EvenlyDivisibleBy(BigInteger number, int maxDiv)
        {
            for (int i = 1; i <= maxDiv; i++)
            {
                if (number % i != 0) { return false; }
            }

            return true;
        }

        #endregion

        #region Problem 6

        /// <summary>
        /// The sum of the squares of the first ten natural numbers is,
        /// 
        /// 1^2 + 2^2 + ... + 10^2 = 385
        /// 
        /// The square of the sum of the first ten natural numbers is,
        /// 
        /// (1 + 2 + ... + 10)^2 = 552 = 3025
        /// 
        /// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
        /// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
        /// /// </summary>
        /// <returns></returns>
        public static double Problem6() => Math.Pow(Enumerable.Range(1, 100).Sum(), 2) - Enumerable.Range(1, 100).Select(x => Math.Pow(x, 2)).Sum();
        #endregion

        #region Problem 7

        /// <summary>
        /// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
        /// What is the 10001st prime number?
        /// </summary>
        /// <returns></returns>
        public static int Problem7()
        {
            return GetPrimeByPosition(10001);
        }

        public static int GetPrimeByPosition(int position)
        {
            if (position == 1) { return 2; }
            else
            {
                int currentPosition = 1;

                for (int num = 3; true; num += 2)
                {
                    if (num.IsPrime())
                    {
                        currentPosition++;
                        if (currentPosition == position)
                        {
                            return num;
                        }
                    }
                }
            }
        }
        #endregion

        #region Problem 8

        /// <summary>
        /// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
        /// 
        ///      73167176531330624919225119674426574742355349194934
        ///      96983520312774506326239578318016984801869478851843
        ///      85861560789112949495459501737958331952853208805511
        ///      12540698747158523863050715693290963295227443043557
        ///      66896648950445244523161731856403098711121722383113
        ///      62229893423380308135336276614282806444486645238749
        ///      30358907296290491560440772390713810515859307960866
        ///      70172427121883998797908792274921901699720888093776
        ///      65727333001053367881220235421809751254540594752243
        ///      52584907711670556013604839586446706324415722155397
        ///      53697817977846174064955149290862569321978468622482
        ///      83972241375657056057490261407972968652414535100474
        ///      82166370484403199890008895243450658541227588666881
        ///      16427171479924442928230863465674813919123162824586
        ///      17866458359124566529476545682848912883142607690042
        ///      24219022671055626321111109370544217506941658960408
        ///      07198403850962455444362981230987879927244284909188
        ///      84580156166097919133875499200524063689912560717606
        ///      05886116467109405077541002256983155200055935729725
        ///      71636269561882670428252483600823257530420752963450
        /// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?        /// </summary>
        /// <returns></returns>
        public static long Problem8()
        {
            string number = "73167176531330624919225119674426574742355349194934" +
                            "96983520312774506326239578318016984801869478851843" +
                            "85861560789112949495459501737958331952853208805511" +
                            "12540698747158523863050715693290963295227443043557" +
                            "66896648950445244523161731856403098711121722383113" +
                            "62229893423380308135336276614282806444486645238749" +
                            "30358907296290491560440772390713810515859307960866" +
                            "70172427121883998797908792274921901699720888093776" +
                            "65727333001053367881220235421809751254540594752243" +
                            "52584907711670556013604839586446706324415722155397" +
                            "53697817977846174064955149290862569321978468622482" +
                            "83972241375657056057490261407972968652414535100474" +
                            "82166370484403199890008895243450658541227588666881" +
                            "16427171479924442928230863465674813919123162824586" +
                            "17866458359124566529476545682848912883142607690042" +
                            "24219022671055626321111109370544217506941658960408" +
                            "07198403850962455444362981230987879927244284909188" +
                            "84580156166097919133875499200524063689912560717606" +
                            "05886116467109405077541002256983155200055935729725" +
                            "71636269561882670428252483600823257530420752963450";

            List<string> listOfGroup = TakeBy(number, 13);

            var listOfIntGroup = listOfGroup.Select(str => str.ToCharArray().Select(c => int.Parse(c.ToString())));
            var multOfIntGroup = listOfIntGroup.Select(list => list.Mult());
            return multOfIntGroup.Max();
        }

        static List<string> TakeBy(string number, int length)
        {
            List<string> result = new List<string>();

            for (int i = 0; i < number.Length - length + 1; i++)
            {
                result.Add(number.Substring(i, length));
            }

            return result;
        }
        #endregion

        #region Problem 9

        /// <summary>
        /// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
        /// 
        ///                                                         a^2 + b^2 = c^2
        /// For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
        /// 
        /// 
        /// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
        /// Find the product abc. 
        /// </summary>
        /// <returns></returns>
        public static int Problem9()
        {
            for (int iC = 0; iC < 1000; iC++)
            {
                for (int iB = 0; iB < iC; iB++)
                {
                    for (int iA = 0; iA < iB; iA++)
                    {
                        if (IsPythagoreanTriplet(iA, iB, iC) && iA + iB + iC == 1000)
                        {
                            return iA * iB * iC;
                        }
                    }
                }
            }
            return 0;
        }

        static bool IsPythagoreanTriplet(int a, int b, int c) => (a * a) + (b * b) == (c * c);

        #endregion

        #region Problems 10 - 19

        #region Problem 10

        /// <summary>
        /// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
        /// 
        /// Find the sum of all the primes below two million.
        /// </summary>
        /// <returns></returns>
        public static long Problem10() => Extra.GetPrimes(2000000).Sum();

        #endregion

        #region Problem 11

        /// <summary>
        /// In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
        /// 
        /// 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
        /// 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
        /// 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
        /// 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
        /// 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
        /// 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
        /// 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 -> 26 (col 9) is marked in red
        /// 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 -> 63 (col 10) is marked in red
        /// 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 -> 78 (col 11) is marked in red
        /// 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 -> 14 (col 12) is marked in red
        /// 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
        /// 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
        /// 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
        /// 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
        /// 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
        /// 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
        /// 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
        /// 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
        /// 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
        /// 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
        /// 
        /// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
        /// What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
        /// </summary>
        /// <returns></returns>
        public static long Problem11()
        {
            List<List<int>> grid = new List<List<int>>() {
                                    new List<int>() {08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08},
                                    new List<int>() {49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00},
                                    new List<int>() {81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65},
                                    new List<int>() {52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91},
                                    new List<int>() {22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80},
                                    new List<int>() {24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50},
                                    new List<int>() {32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70},
                                    new List<int>() {67,26,20,68,02,62,12,20,95,63,94,39,63,08,40,91,66,49,94,21},
                                    new List<int>() {24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72},
                                    new List<int>() {21,36,23,09,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95},
                                    new List<int>() {78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,09,53,56,92},
                                    new List<int>() {16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57},
                                    new List<int>() {86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58},
                                    new List<int>() {19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40},
                                    new List<int>() {04,52,08,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66},
                                    new List<int>() {88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69},
                                    new List<int>() {04,42,16,73,38,25,39,11,24,94,72,18,08,46,29,32,40,62,76,36},
                                    new List<int>() {20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16},
                                    new List<int>() {20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54},
                                    new List<int>() {01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48}
            };

            
            List<List<int>> all = new List<List<int>>();

            List<(int row, int column, int value)> values = GetRowColumnValue(grid);

            all.AddRange(TakeVertical(values.ToList(), 4));
            all.AddRange(TakeHorizontal(values.ToList(), 4));

            var i = 0;
            all.AddRange(TakeVertical(GetRowColumnValue(grid.Select(r => { var res = r.Move(i); i++; return res; }).ToList()), 4));
            all.AddRange(TakeVertical(GetRowColumnValue(grid.Select(r => { var res = r.Move(i); i--; return res; }).ToList()), 4));

            return all.Select(group => group.Mult()).Max();
        }

        private static List<(int row, int column, int value)> GetRowColumnValue(List<List<int>> Numeros)
        {
            List<(int row, int column, int value)> values = new List<(int row, int column, int value)>();

            int iRow = 0;
            foreach (var rowValues in Numeros)
            {
                int iColumn = 0;
                foreach (var columnValue in rowValues)
                {
                    (int row, int column, int value) result = (row: iRow, column: iColumn, value: columnValue);
                    iColumn++;
                    values.Add(result);
                }
                iRow++;
            }

            return values;
        }

        static List<List<int>> TakeVertical(List<(int row, int column, int value)> values, int groupLen)
        {
            return values.GroupBy(x => x.column).Select(gp => gp.Select(d => d)).SelectMany(valuesInColumn => valuesInColumn.Select(a => a.value).ToList().TakeBy(groupLen)).ToList();
        }

        static List<List<int>> TakeHorizontal(List<(int row, int column, int value)> values, int groupLen)
        {
            return values.GroupBy(x => x.row).Select(gp => gp.Select(d => d)).SelectMany(valuesInColumn => valuesInColumn.Select(a => a.value).ToList().TakeBy(groupLen)).ToList();
        }

        #endregion

        #region Problem 12

        /*
         * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
         * The first ten terms would be:
         *              1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
         * 
         * Let us list the factors of the first seven triangle numbers:
         * 
         * 
         * 1: 1
         * 3: 1,3
         * 6: 1,2,3,6
         * 10: 1,2,5,10
         * 15: 1,3,5,15
         * 21: 1,3,7,21
         * 28: 1,2,4,7,14,28
         * 
         * We can see that 28 is the first triangle number to have over five divisors.
         * What is the value of the first triangle number to have over five hundred divisors?
         */

        public static long Problem12()
        {
            long Base = 12250;
            long SumaTriangulo = 1;

            do
            {
                long CantidadM = CantidadMultiplos(SumaTriangulo);

                if (CantidadM >= 500)
                {
                    break;
                }
                else
                {
                    Base++;
                    SumaTriangulo = Base * (Base + 1) / 2;
                }
            } while (true);

            return SumaTriangulo;
        }

        public static long CantidadMultiplos(long Numero)
        {
            int Cantidad = 0;

            for (int i = 1; i <= Numero; i++)
            {
                if (Numero % i == 0)
                {
                    Cantidad++;
                }
            }

            return Cantidad;
        }

        #endregion

        #region Problem 13

        /*
         * Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
         * 
         *                              37107287533902102798797998220837590246510135740250
         *                              46376937677490009712648124896970078050417018260538
         *                              74324986199524741059474233309513058123726617309629
         *                              91942213363574161572522430563301811072406154908250
         *                              23067588207539346171171980310421047513778063246676
         *                              89261670696623633820136378418383684178734361726757
         *                              28112879812849979408065481931592621691275889832738
         *                              44274228917432520321923589422876796487670272189318
         *                              47451445736001306439091167216856844588711603153276
         *                              70386486105843025439939619828917593665686757934951
         *                              62176457141856560629502157223196586755079324193331
         *                              64906352462741904929101432445813822663347944758178
         *                              92575867718337217661963751590579239728245598838407
         *                              58203565325359399008402633568948830189458628227828
         *                              80181199384826282014278194139940567587151170094390
         *                              35398664372827112653829987240784473053190104293586
         *                              86515506006295864861532075273371959191420517255829
         *                              71693888707715466499115593487603532921714970056938
         *                              54370070576826684624621495650076471787294438377604
         *                              53282654108756828443191190634694037855217779295145
         *                              36123272525000296071075082563815656710885258350721
         *                              45876576172410976447339110607218265236877223636045
         *                              17423706905851860660448207621209813287860733969412
         *                              81142660418086830619328460811191061556940512689692
         *                              51934325451728388641918047049293215058642563049483
         *                              62467221648435076201727918039944693004732956340691
         *                              15732444386908125794514089057706229429197107928209
         *                              55037687525678773091862540744969844508330393682126
         *                              18336384825330154686196124348767681297534375946515
         *                              80386287592878490201521685554828717201219257766954
         *                              78182833757993103614740356856449095527097864797581
         *                              16726320100436897842553539920931837441497806860984
         *                              48403098129077791799088218795327364475675590848030
         *                              87086987551392711854517078544161852424320693150332
         *                              59959406895756536782107074926966537676326235447210
         *                              69793950679652694742597709739166693763042633987085
         *                              41052684708299085211399427365734116182760315001271
         *                              65378607361501080857009149939512557028198746004375
         *                              35829035317434717326932123578154982629742552737307
         *                              94953759765105305946966067683156574377167401875275
         *                              88902802571733229619176668713819931811048770190271
         *                              25267680276078003013678680992525463401061632866526
         *                              36270218540497705585629946580636237993140746255962
         *                              24074486908231174977792365466257246923322810917141
         *                              91430288197103288597806669760892938638285025333403
         *                              34413065578016127815921815005561868836468420090470
         *                              23053081172816430487623791969842487255036638784583
         *                              11487696932154902810424020138335124462181441773470
         *                              63783299490636259666498587618221225225512486764533
         *                              67720186971698544312419572409913959008952310058822
         *                              95548255300263520781532296796249481641953868218774
         *                              76085327132285723110424803456124867697064507995236
         *                              37774242535411291684276865538926205024910326572967
         *                              23701913275725675285653248258265463092207058596522
         *                              29798860272258331913126375147341994889534765745501
         *                              18495701454879288984856827726077713721403798879715
         *                              38298203783031473527721580348144513491373226651381
         *                              34829543829199918180278916522431027392251122869539
         *                              40957953066405232632538044100059654939159879593635
         *                              29746152185502371307642255121183693803580388584903
         *                              41698116222072977186158236678424689157993532961922
         *                              62467957194401269043877107275048102390895523597457
         *                              23189706772547915061505504953922979530901129967519
         *                              86188088225875314529584099251203829009407770775672
         *                              11306739708304724483816533873502340845647058077308
         *                              82959174767140363198008187129011875491310547126581
         *                              97623331044818386269515456334926366572897563400500
         *                              42846280183517070527831839425882145521227251250327
         *                              55121603546981200581762165212827652751691296897789
         *                              32238195734329339946437501907836945765883352399886
         *                              75506164965184775180738168837861091527357929701337
         *                              62177842752192623401942399639168044983993173312731
         *                              32924185707147349566916674687634660915035914677504
         *                              99518671430235219628894890102423325116913619626622
         *                              73267460800591547471830798392868535206946944540724
         *                              76841822524674417161514036427982273348055556214818
         *                              97142617910342598647204516893989422179826088076852
         *                              87783646182799346313767754307809363333018982642090
         *                              10848802521674670883215120185883543223812876952786
         *                              71329612474782464538636993009049310363619763878039
         *                              62184073572399794223406235393808339651327408011116
         *                              66627891981488087797941876876144230030984490851411
         *                              60661826293682836764744779239180335110989069790714
         *                              85786944089552990653640447425576083659976645795096
         *                              66024396409905389607120198219976047599490197230297
         *                              64913982680032973156037120041377903785566085089252
         *                              16730939319872750275468906903707539413042652315011
         *                              94809377245048795150954100921645863754710598436791
         *                              78639167021187492431995700641917969777599028300699
         *                              15368713711936614952811305876380278410754449733078
         *                              40789923115535562561142322423255033685442488917353
         *                              44889911501440648020369068063960672322193204149535
         *                              41503128880339536053299340368006977710650566631954
         *                              81234880673210146739058568557934581403627822703280
         *                              82616570773948327592232845941706525094512325230608
         *                              22918802058777319719839450180888072429661980811197
         *                              77158542502016545090413245809786882778948721859617
         *                              72107838435069186155435662884062257473692284509516
         *                              20849603980134001723930671666823555245252804609722
         *                              53503534226472524250874054075591789781264330331690
         */

        public static string Problem13()
        {
            #region ListNumeros
            List<BigInteger> ListNumeros = new List<BigInteger>() {
                BigInteger.Parse("37107287533902102798797998220837590246510135740250"),
                BigInteger.Parse("46376937677490009712648124896970078050417018260538"),
                BigInteger.Parse("74324986199524741059474233309513058123726617309629"),
                BigInteger.Parse("91942213363574161572522430563301811072406154908250"),
                BigInteger.Parse("23067588207539346171171980310421047513778063246676"),
                BigInteger.Parse("89261670696623633820136378418383684178734361726757"),
                BigInteger.Parse("28112879812849979408065481931592621691275889832738"),
                BigInteger.Parse("44274228917432520321923589422876796487670272189318"),
                BigInteger.Parse("47451445736001306439091167216856844588711603153276"),
                BigInteger.Parse("70386486105843025439939619828917593665686757934951"),
                BigInteger.Parse("62176457141856560629502157223196586755079324193331"),
                BigInteger.Parse("64906352462741904929101432445813822663347944758178"),
                BigInteger.Parse("92575867718337217661963751590579239728245598838407"),
                BigInteger.Parse("58203565325359399008402633568948830189458628227828"),
                BigInteger.Parse("80181199384826282014278194139940567587151170094390"),
                BigInteger.Parse("35398664372827112653829987240784473053190104293586"),
                BigInteger.Parse("86515506006295864861532075273371959191420517255829"),
                BigInteger.Parse("71693888707715466499115593487603532921714970056938"),
                BigInteger.Parse("54370070576826684624621495650076471787294438377604"),
                BigInteger.Parse("53282654108756828443191190634694037855217779295145"),
                BigInteger.Parse("36123272525000296071075082563815656710885258350721"),
                BigInteger.Parse("45876576172410976447339110607218265236877223636045"),
                BigInteger.Parse("17423706905851860660448207621209813287860733969412"),
                BigInteger.Parse("81142660418086830619328460811191061556940512689692"),
                BigInteger.Parse("51934325451728388641918047049293215058642563049483"),
                BigInteger.Parse("62467221648435076201727918039944693004732956340691"),
                BigInteger.Parse("15732444386908125794514089057706229429197107928209"),
                BigInteger.Parse("55037687525678773091862540744969844508330393682126"),
                BigInteger.Parse("18336384825330154686196124348767681297534375946515"),
                BigInteger.Parse("80386287592878490201521685554828717201219257766954"),
                BigInteger.Parse("78182833757993103614740356856449095527097864797581"),
                BigInteger.Parse("16726320100436897842553539920931837441497806860984"),
                BigInteger.Parse("48403098129077791799088218795327364475675590848030"),
                BigInteger.Parse("87086987551392711854517078544161852424320693150332"),
                BigInteger.Parse("59959406895756536782107074926966537676326235447210"),
                BigInteger.Parse("69793950679652694742597709739166693763042633987085"),
                BigInteger.Parse("41052684708299085211399427365734116182760315001271"),
                BigInteger.Parse("65378607361501080857009149939512557028198746004375"),
                BigInteger.Parse("35829035317434717326932123578154982629742552737307"),
                BigInteger.Parse("94953759765105305946966067683156574377167401875275"),
                BigInteger.Parse("88902802571733229619176668713819931811048770190271"),
                BigInteger.Parse("25267680276078003013678680992525463401061632866526"),
                BigInteger.Parse("36270218540497705585629946580636237993140746255962"),
                BigInteger.Parse("24074486908231174977792365466257246923322810917141"),
                BigInteger.Parse("91430288197103288597806669760892938638285025333403"),
                BigInteger.Parse("34413065578016127815921815005561868836468420090470"),
                BigInteger.Parse("23053081172816430487623791969842487255036638784583"),
                BigInteger.Parse("11487696932154902810424020138335124462181441773470"),
                BigInteger.Parse("63783299490636259666498587618221225225512486764533"),
                BigInteger.Parse("67720186971698544312419572409913959008952310058822"),
                BigInteger.Parse("95548255300263520781532296796249481641953868218774"),
                BigInteger.Parse("76085327132285723110424803456124867697064507995236"),
                BigInteger.Parse("37774242535411291684276865538926205024910326572967"),
                BigInteger.Parse("23701913275725675285653248258265463092207058596522"),
                BigInteger.Parse("29798860272258331913126375147341994889534765745501"),
                BigInteger.Parse("18495701454879288984856827726077713721403798879715"),
                BigInteger.Parse("38298203783031473527721580348144513491373226651381"),
                BigInteger.Parse("34829543829199918180278916522431027392251122869539"),
                BigInteger.Parse("40957953066405232632538044100059654939159879593635"),
                BigInteger.Parse("29746152185502371307642255121183693803580388584903"),
                BigInteger.Parse("41698116222072977186158236678424689157993532961922"),
                BigInteger.Parse("62467957194401269043877107275048102390895523597457"),
                BigInteger.Parse("23189706772547915061505504953922979530901129967519"),
                BigInteger.Parse("86188088225875314529584099251203829009407770775672"),
                BigInteger.Parse("11306739708304724483816533873502340845647058077308"),
                BigInteger.Parse("82959174767140363198008187129011875491310547126581"),
                BigInteger.Parse("97623331044818386269515456334926366572897563400500"),
                BigInteger.Parse("42846280183517070527831839425882145521227251250327"),
                BigInteger.Parse("55121603546981200581762165212827652751691296897789"),
                BigInteger.Parse("32238195734329339946437501907836945765883352399886"),
                BigInteger.Parse("75506164965184775180738168837861091527357929701337"),
                BigInteger.Parse("62177842752192623401942399639168044983993173312731"),
                BigInteger.Parse("32924185707147349566916674687634660915035914677504"),
                BigInteger.Parse("99518671430235219628894890102423325116913619626622"),
                BigInteger.Parse("73267460800591547471830798392868535206946944540724"),
                BigInteger.Parse("76841822524674417161514036427982273348055556214818"),
                BigInteger.Parse("97142617910342598647204516893989422179826088076852"),
                BigInteger.Parse("87783646182799346313767754307809363333018982642090"),
                BigInteger.Parse("10848802521674670883215120185883543223812876952786"),
                BigInteger.Parse("71329612474782464538636993009049310363619763878039"),
                BigInteger.Parse("62184073572399794223406235393808339651327408011116"),
                BigInteger.Parse("66627891981488087797941876876144230030984490851411"),
                BigInteger.Parse("60661826293682836764744779239180335110989069790714"),
                BigInteger.Parse("85786944089552990653640447425576083659976645795096"),
                BigInteger.Parse("66024396409905389607120198219976047599490197230297"),
                BigInteger.Parse("64913982680032973156037120041377903785566085089252"),
                BigInteger.Parse("16730939319872750275468906903707539413042652315011"),
                BigInteger.Parse("94809377245048795150954100921645863754710598436791"),
                BigInteger.Parse("78639167021187492431995700641917969777599028300699"),
                BigInteger.Parse("15368713711936614952811305876380278410754449733078"),
                BigInteger.Parse("40789923115535562561142322423255033685442488917353"),
                BigInteger.Parse("44889911501440648020369068063960672322193204149535"),
                BigInteger.Parse("41503128880339536053299340368006977710650566631954"),
                BigInteger.Parse("81234880673210146739058568557934581403627822703280"),
                BigInteger.Parse("82616570773948327592232845941706525094512325230608"),
                BigInteger.Parse("22918802058777319719839450180888072429661980811197"),
                BigInteger.Parse("77158542502016545090413245809786882778948721859617"),
                BigInteger.Parse("72107838435069186155435662884062257473692284509516"),
                BigInteger.Parse("20849603980134001723930671666823555245252804609722"),
                BigInteger.Parse("53503534226472524250874054075591789781264330331690")};
            #endregion

            BigInteger Resultado = SumaLista(ListNumeros);

            string Primeros10 = Resultado.ToString().Substring(0, 10);

            return Primeros10;
        }

        static BigInteger SumaLista(List<BigInteger> Lista)
        {
            BigInteger Resultado = 0;

            for (int i = 0; i < Lista.Count; i++)
            {
                Resultado += Lista.ElementAt(i);
            }

            return Resultado;

        }

        static BigInteger SumaLista(List<int> Lista)
        {
            BigInteger Resultado = 0;

            for (int i = 0; i < Lista.Count; i++)
            {
                Resultado += Lista.ElementAt(i);
            }

            return Resultado;

        }

        #endregion

        #region Problem 14

        /*
         * The following iterative sequence is defined for the set of positive integers:
         *          n → n/2 (n is even)
         *          n → 3n + 1 (n is odd)
         *
         * Using the rule above and starting with 13, we generate the following sequence:
         *
         *          13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
         *          
         * It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), 
         * it is thought that all starting numbers finish at 1.
         * 
         * Which starting number, under one million, produces the longest chain?
         * 
         * NOTE: Once the chain starts the terms are allowed to go above one million.
         */


        public static long Problem14()
        {
            long Resultado = 0;

            long TamañoSeqMax = 0;

            for (int i = 999999; i > 0; i--)
            {
                //TamañoSeqMax = Math.Max(TamañoSeq(i), TamañoSeqMax);

                if (TamañoSeq(i) > TamañoSeqMax)
                {
                    TamañoSeqMax = TamañoSeq(i);
                    Resultado = i;
                }
            }


            return Resultado;

        }

        public static long TamañoSeq(long Valor)
        {
            long Cantidad = 0;
            long NuevoValor = Valor;

            while (true)
            {
                NuevoValor = ValorSigiente(NuevoValor);
                Cantidad++;
                if (NuevoValor <= 1)
                {
                    break;
                }
            }

            return Cantidad;
        }

        public static long ValorSigiente(long Valor)
        {
            return (Valor % 2 == 0) ? (Valor / 2) : ((Valor * 3) + 1);
        }


        #endregion

        #region Problem 15

        /*
         * Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
         * 
         * D = Derecha y A = Abajo
         * 
         * DDAA     DADA    DAAD    ADDA    ADAD    AADD
         * 
         * How many such routes are there through a 20×20 grid?
         */

        public static BigInteger Problem15() => Combinatoria(20 * 2, 20);

        static BigInteger Combinatoria(int CantElemento, int CantSubConjunto) => Factorial(CantElemento) / (Factorial(CantSubConjunto) * Factorial(CantElemento - CantSubConjunto));

        static BigInteger Factorial(int Numero)
        {
            BigInteger Res = 1;

            for (int i = 1; i <= Numero; i++)
            {
                Res *= i;
            }

            return Res;
        }

        #endregion

        #region Problem 16

        /// <summary>
        /// 215 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
        /// 
        /// What is the sum of the digits of the number 21000?
        /// </summary>
        /// <returns></returns>
        public static BigInteger Problem16() => SumaDigitos(BigInteger.Pow(2, 1000));

        static BigInteger SumaDigitos(BigInteger Numero, long Exp)
        {
            var S_Numero = Numero.ToString();

            var List_S_Numero = S_Numero.ToCharArray().ToList();

            BigInteger Res = SumaValores(List_S_Numero, Exp);

            return Res;
        }

        static BigInteger SumaFactorialDigitos(BigInteger Numero, List<int> Fact0a9)
        {
            var S_Numero = Numero.ToString();

            var List_S_Numero = S_Numero.ToCharArray().ToList();

            BigInteger Res = SumaFactorialValores(List_S_Numero, Fact0a9);

            return Res;
        }

        public static long SumaValores(List<char> Numeros, long Exp)
        {
            long SumaV = 0;

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += (long)Math.Pow(int.Parse(Numeros.ElementAt(i).ToString()), Exp);
            }

            return SumaV;
        }

        public static long SumaFactorialValores(List<char> Numeros, List<int> Fact0a9)
        {
            long SumaV = 0;

            // List<int> Fact_0a9 = ListaFact_0a9();

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += Fact0a9.ElementAt(int.Parse(Numeros.ElementAt(i).ToString()));
            }

            return SumaV;
        }

        #endregion

        #region Problem 17

        /*
         * If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
         * 
         * If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
         * 
         * NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. 
         * The use of "and" when writing out numbers is in compliance with British usage.
         */

        #endregion

        #region Problem 18

        /*
         * By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
         *
         *                                     3
         *                                    7 4
         *                                   2 4 6
         *                                  8 5 9 3
         *
         *  That is, 3 + 7 + 4 + 9 = 23.
         *  
         * Find the maximum total from top to bottom of the triangle below:

         *                                75
         *                              95 64
         *                             17 47 82
         *                           18 35 87 10
         *                         20 04 82 47 65
         *                        19 01 23 75 03 34
         *                      88 02 77 73 07 63 67
         *                     99 65 04 28 06 16 70 92
         *                   41 41 26 56 83 40 80 70 33
         *                  41 48 72 33 47 32 37 16 94 29
         *                53 71 44 65 25 43 91 52 97 51 14
         *               70 11 33 28 77 73 17 78 39 68 17 57
         *             91 71 52 38 17 14 91 43 58 50 27 29 48
         *            63 66 04 68 89 53 67 30 73 16 69 87 40 31 
         *          04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
         *
         * NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route.
         * However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)
         */


        /*
           //var A = new QuickGraph.AdjacencyGraph<Dato, QuickGraph.Edge<Dato>>();

            //var DatoV1 = new Dato() { valor = 41 };
            //var DatoV2 = new Dato() { valor = 41 };
            //var DatoV3 = new Dato() { valor = 41 };

            //A.AddVertex(DatoV1);
            //A.AddVertex(DatoV2);
            //A.AddVertex(DatoV3);

            //A.AddEdge(new Edge<Dato>(DatoV1, DatoV2));
            //A.AddEdge(new Edge<Dato>(DatoV1, DatoV3));
         
         */


        public static long Problem18()
        {
            List<List<string>> ListaNumeros_S = LeerArchivo("Archivos\\Triangulo1.txt", ' ');

            long Resultado = CalcMax(ListaNumeros_S);

            return Resultado;
        }

        static List<List<string>> LeerArchivo(string Ruta, params char[] Separador)
        {
            List<List<string>> ListaNum = new List<List<string>>();

            StreamReader Archivo = new StreamReader(Ruta);
            do
            {
                string Linea = Archivo.ReadLine();
                if (Linea != null)
                {
                    ListaNum.Add(Linea.Split(Separador).ToList());
                }
                else
                {
                    break;
                }

            } while (true);



            return ListaNum;
        }

        public static long CalcMax(List<List<string>> Lista)
        {
            int Count = Lista.Count;

            for (int L = Count; L > 1; L--)
            {
                List<string> Ultima = Lista.ElementAt(L - 1);
                List<string> AnteUltima = Lista.ElementAt(L - 2);
                List<string> Caminos = new List<string>();

                for (int LL = 0; LL < AnteUltima.Count; LL++)
                {
                    int Camino1 = int.Parse(AnteUltima.ElementAt(LL)) + int.Parse(Ultima.ElementAt(LL));
                    int Camino2 = int.Parse(AnteUltima.ElementAt(LL)) + int.Parse(Ultima.ElementAt(LL + 1));

                    int Camino = Math.Max(Camino1, Camino2);

                    Caminos.Add(Camino.ToString());

                }

                Lista.Remove(Ultima);
                Lista.Remove(AnteUltima);

                Lista.Add(Caminos);
            }

            return long.Parse(Lista.FirstOrDefault().FirstOrDefault());
        }

        #endregion

        #region Problem 19

        /*
         * You are given the following information, but you may prefer to do some research for yourself.
         *      
         *        + 1 Jan 1900 was a Monday.
         *        + Thirty days has September,
         *          April, June and November.
         *          All the rest have thirty-one,
         *          Saving February alone,
         *          Which has twenty-eight, rain or shine.
         *          And on leap years, twenty-nine.
         *        + A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
         *
         * How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
         */

        public static int Problem19()
        {
            string DiaSemana = "Sunday";
            int DiaMes = 1;

            DateTime Inicio = new DateTime(1901, 01, 01);
            DateTime Fin = new DateTime(2000, 12, 31);

            int Resultado = ContarDias(DiaSemana, DiaMes, Inicio, Fin);
            return Resultado;
        }

        private static int ContarDias(string DiaSemana, int DiaMes, DateTime Inicio, DateTime Fin)
        {
            int Cantidad = 0;
            DateTime FechasTmp = new DateTime(Inicio.Ticks);

            while (FechasTmp > Inicio && FechasTmp < Fin)
            {
                if (FechasTmp.DayOfWeek.ToString().Equals(DiaSemana) && (FechasTmp.Day == DiaMes))
                {
                    Cantidad++;
                }
                FechasTmp = FechasTmp.AddDays(1);
            }

            return Cantidad;
        }

        #endregion

        #endregion

        #region Problems 20 - 29

        #region Problem 20

        /*
         * n! means n × (n − 1) × ... × 3 × 2 × 1
         * 
         * For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
         * and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
         * 
         * Find the sum of the digits in the number 100!
         */

        public static BigInteger Problem20() => SumaDigitos(Factorial(100));

        #endregion

        #region Problem 21

        /*Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
         * If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
         * 
         * For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. 
         * The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
         * 
         * Evaluate the sum of all the amicable numbers under 10000.
         */

        public static BigInteger Problem21() => SumaValores(CalAmigosFB(10000));

        static BigInteger SumaValores(List<BigInteger> Numeros)
        {
            BigInteger SumaV = 0;

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += Numeros.ElementAt(i);
            }

            return SumaV;
        }

        private static List<BigInteger> CalAmigosFB(int Maximo)
        {
            List<BigInteger> NumerosAmigos = new List<BigInteger>();

            for (long n = 1; n < Maximo; n++)
            {
                long a = n;
                long b = a.GetFactors(false).Sum(); ;
                var Sumb = b.GetFactors(false).Sum();

                if (b > a && Sumb == a)
                {
                    NumerosAmigos.Add(a);
                    NumerosAmigos.Add(b);
                }
            }


            return NumerosAmigos;
        }

        private static List<BigInteger> CalAmigosFormula(int Maximo)
        {
            List<BigInteger> NumerosAmigos = new List<BigInteger>();

            for (int n = 2; true; n++)
            {
                BigInteger p = (3 * BigInteger.Pow(2, n - 1)) - 1;
                BigInteger q = (3 * BigInteger.Pow(2, n)) - 1;
                BigInteger r = (9 * BigInteger.Pow(2, (2 * n) - 1)) - 1;

                if (p.IsPrime() && q.IsPrime() && r.IsPrime())
                {
                    BigInteger NumTmp = BigInteger.Pow(2, n);
                    BigInteger NumA1 = NumTmp * p * q;
                    BigInteger NumA2 = NumTmp * r;

                    if (NumA1 < Maximo)
                    {
                        NumerosAmigos.Add(NumA1);
                    }

                    if (NumA2 < Maximo)
                    {
                        NumerosAmigos.Add(NumA2);
                    }

                    if (NumA1 >= Maximo || NumA2 >= Maximo)
                    {
                        break;
                    }

                }
            }

            return NumerosAmigos;
        }

        #endregion

        #region Problem 22

        /// <summary>
        /// Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. 
        /// Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
        /// 
        /// For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. 
        /// So, COLIN would obtain a score of 938 × 53 = 49714.
        /// 
        /// What is the total of all the name scores in the file?
        /// </summary>
        /// <returns></returns>
        public static BigInteger Problem22()
        {
            var namesList = LeerArchivo("Archivos\\names.txt", ',').First().Select(str => str.RemoveChars('\"')).ToList();

            namesList.Sort();

            return GetNamesValue(namesList);
        }

        public static long GetNamesValue(List<string> listNames) => listNames.Select(name => GetWordValue(name) * (listNames.IndexOf(name) + 1)).Sum();
        public static int GetWordValue(string word) => word.Select(c => GetLetterValue(c)).Sum();
        public static int GetLetterValue(char letter) => " abcdefghijklmnopqrstuvwxyz".IndexOf(letter);

        #endregion

        #region Problem 23

        /*
         * A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. 
         * For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
         * 
         * A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
         * 
         * As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. 
         * By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.
         * 
         * However, this upper limit cannot be reduced any further by analysis even though it is known that 
         * the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
         * 
         * Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.         * 
         */

        public static long Problem23()
        {
            long Limite = 28123;

            List<long> Lista = new List<long>();

            List<long> NumerosAbundanteslist = NumerosAbundantes(Limite);

            for (int i = 0; i <= Limite; i++)
            {
                if (!SePuedeFormarPorAbundantes(NumerosAbundanteslist, i))
                {
                    Lista.Add(i);
                }
            }

            return Lista.Sum();
        }

        static bool SePuedeFormarPorAbundantes(List<long> NumerosAbundanteslist, int Numero)
        {
            for (int ixAbund = 0; ixAbund < NumerosAbundanteslist.Count; ixAbund++)
            {
                long Abund = NumerosAbundanteslist.ElementAt(ixAbund);
                if (Numero < Abund)
                {
                    break;
                }
                else
                {
                    if (EsAbundante(Numero - Abund))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        static List<long> NumerosAbundantes(long Limite)
        {
            List<long> Lista = new List<long>();

            for (long i = 0; i <= Limite; i++)
            {
                if (EsAbundante(i))
                {
                    Lista.Add(i);
                }
            }

            return Lista;
        }


        static bool EsAbundante(long Numero) => Numero.GetFactors(false).Sum() > Numero;

        #endregion

        #region Problem 24

        /*A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. 
         * If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:
         * 
         *              012   021   102   120   201   210
         * 
         * What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
         */

        public static long Problem24()
        {
            int IdOrden = 1000000;

            List<int> ListaEnteros = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

            List<string> ListaPermutaciones = Permutaciones(ListaEnteros);

            ListaPermutaciones.Sort();

            var tmp = ListaPermutaciones.ElementAt(IdOrden - 1);

            long Resultado = long.Parse(tmp);
            return Resultado;
        }

        static List<string> Permutaciones(List<int> ListaEnteros)
        {
            List<string> ResListaEnteros = new List<string>();

            if (ListaEnteros.Count == 1)
            {
                ResListaEnteros.Add(ListaEnteros.FirstOrDefault().ToString());
            }
            else
            {


                for (int iNumInicio = 0; iNumInicio < ListaEnteros.Count; iNumInicio++)
                {
                    int ValorInicio = ListaEnteros.ElementAt(iNumInicio);

                    int[] ListaEnterostmp_Arr = new int[ListaEnteros.Count];
                    ListaEnteros.CopyTo(ListaEnterostmp_Arr);
                    List<int> ListaEnterostmp = ListaEnterostmp_Arr.ToList();

                    ListaEnterostmp.Remove(ValorInicio);

                    List<string> ListaPermut = Permutaciones(ListaEnterostmp);

                    for (int ii = 0; ii < ListaPermut.Count; ii++)
                    {
                        string tmp = ValorInicio.ToString() + ListaPermut.ElementAt(ii).ToString();
                        ResListaEnteros.Add(tmp);
                        //ResListaEnteros.Add(int.Parse(tmp));
                    }
                }
            }


            ResListaEnteros = ResListaEnteros.Distinct().ToList();

            return ResListaEnteros;
        }


        #endregion

        #region Problem 25

        /*PENDIENTE*/

        /*
         * The Fibonacci sequence is defined by the recurrence relation:
         * 
         *      Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
         * 
         * Hence the first 12 terms will be:
         * 
         *      F1 = 1
         *      F2 = 1
         *      F3 = 2
         *      F4 = 3
         *      F5 = 5
         *      F6 = 8
         *      F7 = 13
         *      F8 = 21
         *      F9 = 34
         *      F10 = 55
         *      F11 = 89
         *      F12 = 144
         *      
         * The 12th term, F12, is the first term to contain three digits.
         * 
         * What is the first term in the Fibonacci sequence to contain 1000 digits?
         */

        public static BigInteger Problem25() => Nro_Termino_Fibonacci_x_DigitoMax(1000);

        static BigInteger Nro_Termino_Fibonacci_x_DigitoMax(BigInteger DigitoMaxMax)
        {
            for (int i = 0; true; i++)
            {
                decimal fTMP = Extra.GetFibonacciValue_ByStep(i);

                if (fTMP.ToString().Length >= DigitoMaxMax)
                {
                    return i;
                }
            }
        }

        #endregion

        #region Problem 26

        /*
         * A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
         * 
         *      1/2	= 	0.5
         *      1/3	= 	0.(3)
         *      1/4	= 	0.25
         *      1/5	= 	0.2
         *      1/6	= 	0.1(6)
         *      1/7	= 	0.(142857)
         *      1/8	= 	0.125
         *      1/9	= 	0.(1)
         *      1/10	= 	0.1
         *      
         * Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
         * 
         * Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
         */

        public static int Problem26()
        {
            int Resultado = 0;

            int Uno = 1;

            int CantDig = 0;

            for (int i = 1000; i > 1; i--)
            {
                int CantDigTmp = CantDigitosPeriodo(Uno, i);

                if (CantDig < CantDigTmp)
                {
                    CantDig = CantDigTmp;
                    Resultado = i;
                }
            }


            return Resultado;
        }

        public static int CantDigitosPeriodo(int Numerador, int Denominador)
        {
            List<int> Restos = new List<int>();

            if (Numerador % Denominador == 0)
            {
                return 0;
            }
            else
            {
                int Entero = Numerador / Denominador;


                int Resto = Numerador - (Entero * Denominador);

                Restos.Add(Resto);
                int RestoTmp = Resto;

                for (int i = 0; ; i++)
                {
                    int NumeradorTmp = RestoTmp * 10;
                    if (NumeradorTmp % Denominador == 0)
                    {
                        return 0;
                    }

                    RestoTmp = NumeradorTmp - (NumeradorTmp / Denominador * Denominador);

                    if (Restos.Contains(RestoTmp))
                    {
                        int Ubicacion = Restos.IndexOf(RestoTmp);
                        return Restos.Count - Ubicacion;
                    }
                    else
                    {
                        Restos.Add(RestoTmp);
                    }
                }
            }
        }


        #endregion

        #region Problem 27

        /*
         * Euler discovered the remarkable quadratic formula:
         *          n² + n + 41
         *          
         * It turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39. 
         * However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible by 41.
         * 
         * The incredible formula  n² − 79n + 1601 was discovered, which produces 80 primes for the consecutive values n = 0 to 79. 
         * The product of the coefficients, −79 and 1601, is −126479.
         * 
         * Considering quadratics of the form:
         * 
         *          n² + an + b, where |a| < 1000 and |b| < 1000
         *          
         * where |n| is the modulus/absolute value of n
         * e.g. |11| = 11 and |−4| = 4
         * 
         * Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.
         */


        public static long Problem27()
        {
            _ = MaximaSecuencia(out long A, out long B);

            return A * B;
        }

        public static long MaximaSecuencia(out long outA, out long outB)
        {
            long Maxima = 0;
            outA = 0;
            outB = 0;

            List<long> PrimosTodos = Extra.GetPrimes(1000000);
            List<long> B_Primos = Extra.GetPrimes(1000, true);

            for (int A = -999; A <= 1000; A += 2)
            {
                for (int indexB = 0; indexB < B_Primos.Count(); indexB++)
                {
                    long TamSeq = NroSecuenciaPrimos(PrimosTodos, A, B_Primos.ElementAt(indexB));

                    if (Maxima < TamSeq)
                    {
                        outA = A;
                        outB = B_Primos.ElementAt(indexB);
                        Maxima = TamSeq;
                    }
                }
            }

            return Maxima;
        }

        public static long NroSecuenciaPrimos(List<long> PrimosTodos, long A, long B)
        {
            for (long n = 0; ; n++)
            {
                if (!PrimosTodos.Contains(FormulaCuadrada(n, A, B)))
                {
                    return n - 1;
                }
            }
        }

        public static long FormulaCuadrada(long n, long a, long b) => long.Parse(Math.Pow(n, 2).ToString()) + (a * n) + b;

        #endregion

        #region Problem 28

        /*
         * Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
         * 
         *          21 22 23 24 25
         *          20  7  8  9 10
         *          19  6  1  2 11
         *          18  5  4  3 12
         *          17 16 15 14 13
         *          
         * It can be verified that the sum of the numbers on the diagonals is 101.
         * 
         * What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
         */

        public static long Problem28()
        {
            int Max = 1001;

            var L_IndexDiagonal = ListaIndexDiagonal(Max);

            long Resultado = SumaDiagonal(L_IndexDiagonal);
            return Resultado;
        }

        static List<long> ListaIndexDiagonal(long Length)
        {
            List<long> Res = new List<long>();

            long Index = 0;
            Res.Add(Index);

            for (int i = 1; ; i++)
            {
                for (int m = 0; m < 4; m++)
                {
                    Index += (2 * i);
                    Res.Add(Index);
                }

                if (Index >= (Length * Length) - 1)
                {
                    break;
                }
            }

            return Res;
        }

        public static long SumaDiagonal(List<long> ListaIndexDiagonal)
        {
            long Res = 0;

            for (int i = 0; i < ListaIndexDiagonal.Count; i++)
            {
                Res += (int)ListaIndexDiagonal.ElementAt(i) + 1;
            }


            return Res;
        }

        #endregion

        #region Problem 29

        /*
         * Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
         * 
         *      2^2=4, 2^3=8, 2^4=16, 2^5=32
         *      3^2=9, 3^3=27, 3^4=81, 3^5=243
         *      4^2=16, 4^3=64, 4^4=256, 4^5=1024
         *      5^2=25, 5^3=125, 5^4=625, 5^5=3125
         *      
         * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
         * 
         *      4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
         *      
         * How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
         */

        public static int Problem29() => CrearLista(2, 100, 2, 100).Count();

        static List<BigInteger> CrearLista(int minA, int maxA, int minB, int maxB)
        {
            List<BigInteger> Res = new List<BigInteger>();

            for (int a = minA; a <= maxA; a++)
            {
                for (int b = minB; b <= maxB; b++)
                {
                    BigInteger nuevoValor = BigInteger.Pow(a, b);
                    if (!Res.Contains(nuevoValor))
                    {
                        Res.Add(nuevoValor);
                    }
                }
            }


            return Res;
        }


        #endregion

        #endregion

        #region Problems 30 - 39

        #region Problem 30

        /*
         * Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
         * 
         *          1634 = 1^4 + 6^4 + 3^4 + 4^4
         *          8208 = 8^4 + 2^4 + 0^4 + 8^4
         *          9474 = 9^4 + 4^4 + 7^4 + 4^4
         *          
         * As 1 = 14 is not a sum it is not included.
         * 
         * The sum of these numbers is 1634 + 8208 + 9474 = 19316.
         * 
         * Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
         */

        public static BigInteger Problem30() => SumaLista(CrearListaNar());

        private static List<BigInteger> CrearListaNar()
        {
            List<BigInteger> ListNrosNar = new List<BigInteger>();

            //10 > para que sea una Suma de Digitos.
            //360000 > 6 * 9^5

            for (BigInteger i = 10; i <= 360000; i++)
            {
                BigInteger Suma = SumaDigitos(i, 5);
                if (Suma == i)
                {
                    ListNrosNar.Add(i);
                }
            }
            return ListNrosNar;
        }

        public static long SumaExp(List<long> Lista, long Exp)
        {
            long Res = 0;

            for (int i = 0; i < Lista.Count; i++)
            {
                Res += (long)Math.Pow(Lista.ElementAt(i), Exp);
            }

            return Res;
        }

        static BigInteger SumaDigitos(BigInteger Numero)
        {
            var S_Numero = Numero.ToString();

            List<char> List_S_Numero = S_Numero.ToCharArray().ToList();

            BigInteger Res = SumaValores(List_S_Numero);

            return Res;
        }

        public static long SumaValores(List<char> Numeros)
        {
            long SumaV = 0;

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += int.Parse(Numeros.ElementAt(i).ToString());
            }

            return SumaV;
        }

        #endregion

        #region Problem 31

        /*
         * In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:
         * 
         *              1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
         *              
         * It is possible to make £2 in the following way:
         * 
         *              1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
         *              
         * How many different ways can £2 be made using any number of coins?
         */

        public static int Problem31() => Posibles(200).Count();

        public static int SumaMonedas(List<int> CantidadesMonedas)
        {
            List<int> coin = new List<int> { 200, 100, 50, 20, 10, 5, 2, 1 };

            int Res = 0;

            for (int i = 0; i < CantidadesMonedas.Count; i++)
            {
                Res += CantidadesMonedas.ElementAt(i) * coin.ElementAt(i);
            }


            return Res;
        }

        static List<List<int>> Posibles(int Pence)
        {
            List<List<int>> Res = new List<List<int>>();

            List<int> L_ResTmp = new List<int>();


            for (int l2 = 0; l2 <= Pence; l2 += 200)
            {
                L_ResTmp.Add(l2);
                for (int l1 = l2; l1 <= Pence; l1 += 100)
                {
                    L_ResTmp.Add(l1);
                    for (int p50 = l1; p50 <= Pence; p50 += 50)
                    {
                        L_ResTmp.Add(p50);
                        for (int p20 = p50; p20 <= Pence; p20 += 20)
                        {
                            L_ResTmp.Add(p20);
                            for (int p10 = p20; p10 <= Pence; p10 += 10)
                            {
                                L_ResTmp.Add(p10);
                                for (int p5 = p10; p5 <= Pence; p5 += 5)
                                {
                                    L_ResTmp.Add(p5);
                                    for (int p2 = p5; p2 <= Pence; p2 += 2)
                                    {

                                        L_ResTmp.Add(p2);
                                        //L_ResTmp.AddRange(new List<int> { l2, l1, p50, p20, p10, p5 });

                                        int p1 = Pence - SumaMonedas(L_ResTmp);
                                        L_ResTmp.Add(p1);

                                        List<int> L_ResTmpTmp = new List<int>();

                                        L_ResTmpTmp.AddRange(L_ResTmp);

                                        //if (!Res.Contains(L_ResTmpTmp) && SumaMonedas(L_ResTmpTmp) == Pence)
                                        //{
                                        Res.Add(L_ResTmpTmp);
                                        //}

                                        L_ResTmp.Remove(p1);


                                        L_ResTmp.Remove(p2);
                                    }
                                    L_ResTmp.Remove(p5);
                                }
                                L_ResTmp.Remove(p10);
                            }
                            L_ResTmp.Remove(p20);
                        }
                        L_ResTmp.Remove(p50);
                    }
                    L_ResTmp.Remove(l1);
                }
                L_ResTmp.Remove(l2);
            }

            return Res;
        }

        #endregion

        #region Problem 32

        /*
         * We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; 
         * for example, the 5-digit number, 15234, is 1 through 5 pandigital.
         * 
         * The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.
         * 
         * Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
         * 
         * HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
         */

        public static BigInteger Problem32()
        {
            List<int> ListaEnteros = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

            List<string> ListaPermutaciones = Permutaciones(ListaEnteros);

            ListaPermutaciones.Sort();

            List<int> Productos = ObtenerProductos(ListaPermutaciones);

            BigInteger Resultado = SumaLista(Productos);

            return Resultado;
        }

        static List<int> ObtenerProductos(List<string> ListaPermutaciones)
        {
            List<int> Res = new List<int>();

            for (int iPerm = 0; iPerm < ListaPermutaciones.Count; iPerm++)
            {
                string TMP = ListaPermutaciones.ElementAt(iPerm);

                List<string[]> Lista = CombProductos(TMP);

                for (int iLista = 0; iLista < Lista.Count; iLista++)
                {
                    string[] as_tmp = Lista.ElementAt(iLista);

                    int Term1 = int.Parse(as_tmp[0]);
                    int Term2 = int.Parse(as_tmp[1]);
                    int Term3 = int.Parse(as_tmp[2]);

                    if (Term1 * Term2 == Term3)
                    {
                        if (!Res.Contains(Term3))
                        {
                            Res.Add(Term3);
                        }
                    }
                }

            }



            return Res;
        }

        static List<string[]> CombProductos(string Producto)
        {
            List<string[]> res = new List<string[]>();

            string[] restmp;

            //char[] ac_Producto = Producto.TocharArray();

            for (int CantTerm1 = 1; CantTerm1 <= Producto.Length - 2; CantTerm1++)
            {
                for (int CantTerm2 = 1; CantTerm2 <= Producto.Length - CantTerm1 - 1; CantTerm2++)
                {
                    int CantTerm3 = Producto.Length - CantTerm1 - CantTerm2;

                    restmp = new string[3];

                    restmp[0] = Producto.Substring(0, CantTerm1);
                    restmp[1] = Producto.Substring(CantTerm1, CantTerm2);
                    restmp[2] = Producto.Substring(CantTerm1 + CantTerm2, CantTerm3);

                    res.Add(restmp);
                }
            }

            return res;
        }

        #endregion

        #region Problem 33

        /*
         * The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, 
         * which is correct, is obtained by cancelling the 9s.
         * 
         * We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
         * 
         * There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.
         * 
         * If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
         */

        public static int Problem33()
        {
            List<int[]> Facciones = ObtenerFracciones();

            int[] MF = MultipFracciones(Facciones);

            return BruteForce_mathblog();
        }

        static List<int[]> ObtenerFracciones()
        {
            List<int[]> Res = new List<int[]>();

            for (int i = 1; i < 10; i++)
            {
                for (int n = 1; n < 10; n++)
                {
                    for (int d = 1; d < 10; d++)
                    {
                        if (d != n)
                        {

                            double t1;
                            double t2;
                            double t3;

                            t3 = (double)(n / (double)d);

                            t1 = (i * 10) + n;
                            t2 = (i * 10) + d;


                            bool Pro1 = t1 / t2 == t3;
                            if (Pro1)
                            {
                                var t = new int[] { (i * 10) + n, (i * 10) + d, i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }

                            // bool Pro2 = (double)((double)(n * 10 + i) / (double)(d * 10 + i)) == (double)(n / d);

                            t1 = (n * 10) + i;
                            t2 = (d * 10) + i;


                            bool Pro2 = t1 / t2 == t3;
                            if (Pro2)
                            {
                                var t = new int[] { (n * 10) + i, (d * 10) + i, i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }

                            //bool Pro3 = (double)((double)(i * 10 + n) / (double)(d * 10 + i)) == (double)(n / d);

                            t1 = (i * 10) + n;
                            t2 = (d * 10) + i;

                            bool Pro3 = t1 / t2 == t3;
                            if (Pro3)
                            {
                                var t = new int[] { (i * 10) + n, (d * 10) + i, i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }

                            // bool Pro4 = (double)((double)(n * 10 + i) / (double)(i * 10 + d)) == (double)(n / d);

                            t1 = (n * 10) + i;
                            t2 = (i * 10) + d;

                            if (t1 / t2 == t3)
                            {
                                var t = new int[] { (n * 10) + i, (i * 10) + d, i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }
                        }
                    }
                }
            }

            return Res;
        }

        static int[] MultipFracciones(List<int[]> Facciones)
        {
            int[] MulFacciones = new int[2];

            int Numer = 1;
            int Denomi = 1;


            for (int i = 0; i < Facciones.Count; i++)
            {
                Numer *= Facciones.ElementAt(i)[0];
                Denomi *= Facciones.ElementAt(i)[1];
            }

            MulFacciones[0] = Numer;
            MulFacciones[1] = Denomi;


            return MulFacciones;
        }


        public static int BruteForce_mathblog()
        {
            int denproduct = 1;
            int nomproduct = 1;

            for (int i = 1; i < 10; i++)
            {
                for (int den = 1; den < i; den++)
                {
                    for (int nom = 1; nom < den; nom++)
                    {
                        if ((nom * 10) + (i * den) == nom * ((i * 10) + den))
                        {
                            denproduct *= den;
                            nomproduct *= nom;
                        }
                    }
                }
            }

            denproduct /= GCD_mathblog(nomproduct, denproduct);


            // Console.WriteLine("The product of denominators {0}", denproduct);

            return denproduct;
        }

        static private int GCD_mathblog(int a, int b)
        {
            int y, x;

            if (a > b)
            {
                x = a;
                y = b;
            }
            else
            {
                x = b;
                y = a;
            }

            while (x % y != 0)
            {
                int temp = x;
                x = y;
                y = temp % x;
            }

            return y;
        }


        #endregion

        #region Problem 34

        /*
         * 145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
         * 
         * Find the sum of all numbers which are equal to the sum of the factorial of their digits.
         * 
         * Note: as 1! = 1 and 2! = 2 are not sums they are not included.
         */

        public static BigInteger Problem34() => SumaLista(ListaNumerosSumaFact());

        static List<int> ListaNumerosSumaFact()
        {
            BigInteger LimiteSup = Factorial(9) * 7; // Factorial(9) * 7 = (7 digitos)   |||   Factorial(9) * 8 = (7 digitos)

            List<int> Fact_0a9 = ListaFact_0a9();

            List<int> Res = new List<int>();

            for (int i = 10; i <= LimiteSup; i++)
            {
                if (i == SumaFactorialDigitos(i, Fact_0a9))
                    Res.Add(i);
            }


            return Res;
        }


        static List<int> ListaFact_0a9()
        {
            List<int> Fac = new List<int>();

            for (int i = 0; i < 10; i++)
            {
                Fac.Add(int.Parse(Factorial(i).ToString()));
            }

            return Fac;
        }



        #endregion

        #region Problem 35

        /*
         *The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
         *
         * There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
         * 
         * How many circular primes are there below one million?
         */

        public static BigInteger Problem35()
        {
            long Millon = 1000000;

            List<long> listaPrimosCirculares = ListaPrimosCirculares(Millon);

            listaPrimosCirculares.Sort();

            return listaPrimosCirculares.Distinct().Count();
        }

        private static List<long> ListaPrimosCirculares(long Millon)
        {
            List<long> R = new List<long>();
            List<long> NO_R = new List<long>();

            List<long> PrimosBajo = Extra.GetPrimes(Millon, false);

            for (int i = 0; i < PrimosBajo.Count; i++)
            {
                long Tmp = PrimosBajo.ElementAt(i);
                if (!R.Contains(Tmp) && !NO_R.Contains(Tmp))
                {
                    List<long> Perm = ListStringToListlong(Permutaciones(ToDigitsList(Tmp)));

                    if (SonPrimos(Perm, PrimosBajo))
                    {
                        R.AddRange(Perm);
                    }
                    else
                    {
                        //NO_R.AddRange(Perm);
                    }
                }
            }
            return R;
        }

        static List<int> ToDigitsList(long Numero)
        {
            List<int> Res = new List<int>();

            var Lis = Numero.ToString().ToCharArray();

            for (int i = 0; i < Lis.Length; i++)
            {
                Res.Add(int.Parse(Lis[i].ToString()));
            }

            return Res;
        }

        static bool SonPrimos(List<long> String_Primo, List<long> Primos)
        {
            for (int i = 0; i < String_Primo.Count; i++)
            {
                if (!Primos.Contains(String_Primo.ElementAt(i)))
                    return false;
            }

            return true;
        }

        static List<long> ListStringToListlong(List<string> String_)
        {
            List<long> R = new List<long>();

            for (int i = 0; i < String_.Count; i++)
            {
                R.Add(long.Parse(String_.ElementAt(i)));
            }

            return R;
        }

        static public long CheckCircularPrimes(long prime, List<long> Primos)
        {
            int multiplier = 1;
            long number = prime;
            long count = 0;
            long d;

            //Count the digits and check for even numbers
            while (number > 0)
            {
                d = number % 10;
                if (d % 2 == 0 || d == 5)
                {
                    Primos.Remove(prime);
                    return 0;
                }
                number /= 10;
                multiplier *= 10;
                count++;
            }
            multiplier /= 10;

            //Rotate the number and check if they are prime
            number = prime;
            List<long> foundCircularPrimes = new List<long>();

            for (int i = 0; i < count; i++)
            {
                if (Primos.Contains(number))
                {
                    foundCircularPrimes.Add(number);
                    Primos.Remove(number);
                }
                else if (!foundCircularPrimes.Contains(number))
                {
                    return 0;
                }

                d = number % 10;
                number = (d * multiplier) + (number / 10);
            }

            return foundCircularPrimes.Count;
        }

        static public long BruteForce(List<long> Primos)
        {


            long noCircularPrimes = 2;

            //Special cases
            Primos.Remove(2);
            Primos.Remove(5);

            while (Primos.Count > 0)
            {
                noCircularPrimes += CheckCircularPrimes(Primos.Min(), Primos);
            }

            return noCircularPrimes;
        }


        #endregion

        #endregion

        #region Problem 64

        /*
         * By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
         *
         *                                     3
         *                                    7 4
         *                                   2 4 6
         *                                  8 5 9 3
         *
         *  That is, 3 + 7 + 4 + 9 = 23.
         *  
         * Find the maximum total from top to bottom in triangle.txt (right click and 'Save Link/Target As...'), a 15K text file containing a triangle with one-hundred rows.
         * 
         * NOTE: This is a much more difficult version of Problem 18. It is not possible to try every route to solve this problem, as there are 299 altogether!
         * If you could check one trillion (1012) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it. ;o)
         */

        public static long Problem64()
        {
            List<List<string>> ListaNumeros_S = LeerArchivo("Archivos\\Triangulo2.txt");

            long Resultado = CalcMax(ListaNumeros_S);
            return Resultado;
        }

        #endregion
    }
}
