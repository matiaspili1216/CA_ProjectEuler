using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.IO;

namespace CA_ProjectEuler
{
    static class Program
    {
        static void Main(string[] args)
        {
            var Rta = Problema21();
            
            Console.WriteLine(Rta);

            Console.ReadLine();
        }

        #region Problemas 1 - 9

        #region Problema 1
        /*
         * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
         * Find the sum of all the multiples of 3 or 5 below 1000.
         */

        static int Problema1()
        {
            int Suma = 0;
            int Max = 1000;
            int[] Multipos = new int[] { 3, 5 };

            for (int i = 0; i < Max; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    Suma += i;
                }
            }

            return Suma;
        }
        #endregion

        #region Problema 2
        /*
         * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
         * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
         * 
         * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
         */

        static int Problema2()
        {
            List<int> FiboFinal = new List<int>();

            FiboFinal = Fibonacci_x_ResultadoMax(4000000);
            // FiboFinal = Fibo_Cantidad(10);


            int Ultimos2Terminos = SumaUltimos2TerminosPares(FiboFinal);

            return Ultimos2Terminos;

        }


        static int SumaUltimos2TerminosPares(List<int> FiboFinal)
        {
            List<int> FiboFinalPares = FiboFinal.Where(p => p % 2 == 0).ToList<int>();

            //return FiboFinalPares.ElementAt(FiboFinalPares.Count - 1) + FiboFinalPares.ElementAt(FiboFinalPares.Count - 2);
            return FiboFinalPares.Sum();
        }

        static long Fibonacci(int Pasos)
        {
            //int a = 1;
            //int b = 2;

            //for (int i = 0; i < Pasos; i++)
            //{
            //    int temp = a;
            //    a = b;
            //    b = temp + b;
            //}

            //return a;

            if (Pasos <= 1)
            {
                return 1;
            }
            else
            {
                int n = Pasos;
                decimal Sqrt5 = (decimal)Math.Sqrt(5.0);

                decimal NroAureo = ((1 + Sqrt5) / 2);

                decimal a_ = (Exp(NroAureo, n) - (Exp(1 - NroAureo, n))) / Sqrt5;

                // return ((BigInteger.Parse(((long)a_).ToString())));

                return (long)(a_);
            }

        }

        static List<Decimal> Fibonacci_x_Cantidad(int CantidadPasos)
        {
            List<Decimal> retFibo = new List<Decimal>();

            for (int i = 0; i < CantidadPasos; i++)
            {
                retFibo.Add(Fibonacci(i));
            }

            return retFibo;
        }

        static List<int> Fibonacci_x_ResultadoMax(int ResultadoMax)
        {
            List<int> retFibo = new List<int>();

            for (int i = 0; true; i++)
            {
                int fTMP = int.Parse(Fibonacci(i).ToString());

                if (fTMP < ResultadoMax)
                {
                    retFibo.Add(fTMP);
                }
                else
                {
                    break;
                }

            }

            return retFibo;
        }

        #endregion

        #region Problema 3

        /*
         * The prime factors of 13195 are 5, 7, 13 and 29.
         * 
         * What is the largest prime factor of the number 600851475143 ?
         */

        static long Problema3()
        {
            long NuemroCalculo = 600851475143;

            List<long> FactoresNumPrimos = FactoresPrimos(NuemroCalculo).Where(p => EsPrimo(p)).ToList<long>();

            return FactoresNumPrimos.Last();

        }

        static List<long> Factores(long Numero, bool IncluirNumero = true)
        {
            List<long> FactoresN = new List<long>();

            long Max = IncluirNumero ? Numero : Numero - 1;

            for (long i = 1; i <= Max; i++)
            {
                if (Numero % i == 0)
                {
                    FactoresN.Add(i);
                }
            }

            return FactoresN;
        }

        static List<long> FactoresPrimos(long Numero, bool IncluirNumero = true)
        {
            List<long> FactoresN = new List<long>();

            FactoresN.Add(2);


            long Max = IncluirNumero ? Numero : Numero - 1;

            for (long i = 3; i <= Max; i++)
            {
                if (Numero % i == 0)
                {
                    if (EsPrimo(i))
                    {
                        FactoresN.Add(i);
                    }

                }

                i++;
            }

            return FactoresN;
        }

        static Boolean EsPrimo(long Numero)
        {
            return EsPrimo((BigInteger)Numero);
        }

        static Boolean EsPrimo(BigInteger Numero)
        {
            if (Numero == 1)
            {
                return false;
            }
            else if (Numero == 2)
            {
                return true;
            }
            else
            {
                for (BigInteger i = 2; i < Numero; i++)
                {
                    if (Numero % i == 0)
                    {
                        return false;
                    }

                }
            }

            return true;
        }



        static Boolean EsPrimo(int Numero)
        {
            if (Numero == 1)
            {
                return false;
            }
            else if (Numero == 2)
            {
                return true;
            }
            else
            {
                for (long i = 2; i < Numero; i++)
                {
                    if (Numero % i == 0)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        #endregion

        #region Problema 4

        /*
         * A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
         * 
         * Find the largest palindrome made from the product of two 3-digit numbers.
         */

        static int Problema4()
        {
            int MaxPal = MaxPalindromo();

            return MaxPal;
        }

        private static int MaxPalindromo()
        {
            int PalActual = 0;
            for (int i = 999; i >= 100; i--)
            {
                for (int ii = 999; ii >= 100; ii--)
                {
                    int mult = i * ii;

                    if (EsPalindromo(mult))
                    {
                        PalActual = Math.Max(mult, PalActual);
                    }
                }
            }

            return PalActual;
        }

        static Boolean EsPalindromo(int Numero)
        {
            string S_Numero = Numero.ToString();
            int CantidadInicio = S_Numero.Length % 2 == 0 ? S_Numero.Length / 2 : (S_Numero.Length - 1) / 2;

            string Inicio = S_Numero.Substring(0, CantidadInicio);

            string Fin = (new string(S_Numero.Reverse().ToArray())).Substring(0, CantidadInicio);

            return Inicio.ToLower().Equals(Fin.ToLower());
        }

        #endregion

        #region Problema 5

        static int Problema5()
        {
            for (int i = 20; true; i++)
            {
                if (EsDivPorTodos(i, 20))
                {
                    return i;
                }
            }
        }

        static Boolean EsDivPorTodos(int Numero, int MaxDiv)
        {
            for (int i = 1; i < MaxDiv; i++)
            {
                if (Numero % i != 0)
                {
                    return false;
                }
            }

            return true;
        }

        #endregion

        #region Problema 6

        /*
         * The sum of the squares of the first ten natural numbers is,
         * 
         * 12 + 22 + ... + 102 = 385
         * 
         * The square of the sum of the first ten natural numbers is,
         * 
         * (1 + 2 + ... + 10)2 = 552 = 3025
         * 
         * Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
         * Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
         */

        static int Problema6()
        {
            int Numero = 100;

            return (CuadradosSuma(Numero) - SumaCuadrados(Numero));
        }

        static int SumaCuadrados(int Numero)
        {
            int Resultado = 0;

            for (int i = 0; i <= Numero; i++)
            {
                Resultado += i * i;
            }

            return Resultado;
        }

        static int CuadradosSuma(int Numero)
        {
            int Resultado = 0;

            for (int i = 0; i <= Numero; i++)
            {
                Resultado += i;
            }

            return Resultado * Resultado;
        }

        #endregion

        #region Problema 7

        /*
         * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
         * What is the 10001st prime number?
         */

        static int Problema7()
        {
            return Primos(10001);
        }


        static int Primos(int LengthArray)
        {
            int PrimoActual = 2;
            int PosicionPrimo = 1;

            for (int iEx = 3; true; iEx++)
            {
                if (EsPrimo(iEx))
                {
                    PrimoActual = iEx;
                    PosicionPrimo++;
                }

                if (PosicionPrimo == LengthArray)
                {
                    break;
                }

                iEx++;
            }

            return PrimoActual;
        }
        #endregion

        #region Problema 8

        /*
         * The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
         * 
         *      73167176531330624919225119674426574742355349194934
         *      96983520312774506326239578318016984801869478851843
         *      85861560789112949495459501737958331952853208805511
         *      12540698747158523863050715693290963295227443043557
         *      66896648950445244523161731856403098711121722383113
         *      62229893423380308135336276614282806444486645238749
         *      30358907296290491560440772390713810515859307960866
         *      70172427121883998797908792274921901699720888093776
         *      65727333001053367881220235421809751254540594752243
         *      52584907711670556013604839586446706324415722155397
         *      53697817977846174064955149290862569321978468622482
         *      83972241375657056057490261407972968652414535100474
         *      82166370484403199890008895243450658541227588666881
         *      16427171479924442928230863465674813919123162824586
         *      17866458359124566529476545682848912883142607690042
         *      24219022671055626321111109370544217506941658960408
         *      07198403850962455444362981230987879927244284909188
         *      84580156166097919133875499200524063689912560717606
         *      05886116467109405077541002256983155200055935729725
         *      71636269561882670428252483600823257530420752963450
         * Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
         */


        static long Problema8()
        {
            string Numero = "73167176531330624919225119674426574742355349194934" +
                            "96983520312774506326239578318016984801869478851843" +
                            "85861560789112949495459501737958331952853208805511" +
                            "12540698747158523863050715693290963295227443043557" +
                            "66896648950445244523161731856403098711121722383113" +
                            "62229893423380308135336276614282806444486645238749" +
                            "30358907296290491560440772390713810515859307960866" +
                            "70172427121883998797908792274921901699720888093776" +
                            "65727333001053367881220235421809751254540594752243" +
                            "52584907711670556013604839586446706324415722155397" +
                            "53697817977846174064955149290862569321978468622482" +
                            "83972241375657056057490261407972968652414535100474" +
                            "82166370484403199890008895243450658541227588666881" +
                            "16427171479924442928230863465674813919123162824586" +
                            "17866458359124566529476545682848912883142607690042" +
                            "24219022671055626321111109370544217506941658960408" +
                            "07198403850962455444362981230987879927244284909188" +
                            "84580156166097919133875499200524063689912560717606" +
                            "05886116467109405077541002256983155200055935729725" +
                            "71636269561882670428252483600823257530420752963450";

            string[] Numeros = new string[] {   "73167176531330624919225119674426574742355349194934",
                                                "96983520312774506326239578318016984801869478851843",
                                                "85861560789112949495459501737958331952853208805511",
                                                "12540698747158523863050715693290963295227443043557",
                                                "66896648950445244523161731856403098711121722383113",
                                                "62229893423380308135336276614282806444486645238749",
                                                "30358907296290491560440772390713810515859307960866",
                                                "70172427121883998797908792274921901699720888093776",
                                                "65727333001053367881220235421809751254540594752243",
                                                "52584907711670556013604839586446706324415722155397",
                                                "53697817977846174064955149290862569321978468622482",
                                                "83972241375657056057490261407972968652414535100474",
                                                "82166370484403199890008895243450658541227588666881",
                                                "16427171479924442928230863465674813919123162824586",
                                                "17866458359124566529476545682848912883142607690042",
                                                "24219022671055626321111109370544217506941658960408",
                                                "07198403850962455444362981230987879927244284909188",
                                                "84580156166097919133875499200524063689912560717606",
                                                "05886116467109405077541002256983155200055935729725",
                                                "71636269561882670428252483600823257530420752963450"};

            List<string> NumeroGrupo = AgruparNumero(Numero, 13);

            long Max = MaxMult(NumeroGrupo);

            return Max;
        }

        static List<string> AgruparNumero(string Numero, int TamañoGrupo)
        {
            List<string> NumeroGrupo = new List<string>();

            for (int i = 0; i < (Numero.Length - TamañoGrupo) + 1; i++)
            {
                NumeroGrupo.Add(Numero.Substring(i, TamañoGrupo));
            }

            return NumeroGrupo;
        }

        static List<string> AgruparNumero(string[] Numeros, int TamañoGrupo)
        {
            List<string> NumeroGrupo = new List<string>();

            for (int iNumeros = 0; iNumeros < Numeros.Length; iNumeros++)
            {
                for (int i = 0; i < (Numeros[iNumeros].Length - TamañoGrupo) + 1; i++)
                {
                    NumeroGrupo.Add(Numeros[iNumeros].Substring(i, TamañoGrupo));
                }
            }

            return NumeroGrupo;
        }

        static long MaxMult(List<string> NumeroGrupo)
        {
            long Mult = 0;

            List<long> TodosMult = new List<long>();


            for (int i = 0; i < NumeroGrupo.Count; i++)
            {
                long Resultado = 1;
                char[] Caracteres = NumeroGrupo.ElementAt(i).ToCharArray();

                for (int iCar = 0; iCar < Caracteres.Length; iCar++)
                {
                    Resultado *= long.Parse(Caracteres[iCar].ToString());
                }

                Mult = Math.Max(Mult, Resultado);

                TodosMult.Add(Resultado);
            }

            //return Mult;
            return Max(TodosMult);
        }


        static long Max(List<long> ListLong)
        {
            long Max = 0;
            for (int i = 0; i < ListLong.Count; i++)
            {
                Max = Math.Max(ListLong.ElementAt(i), Max);
            }

            return Max;
        }
        #endregion

        #region Problema 9

        /*
         * A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
         * 
         *                                                         a2 + b2 = c2
         * For example, 32 + 42 = 9 + 16 = 25 = 52.
         * 
         * 
         * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
         * Find the product abc.
         */

        static int Problema9()
        {
            int ValorSuma = 1000;

            for (int iC = 0; iC < 1000; iC++)
            {
                for (int iB = 0; iB < iC; iB++)
                {
                    for (int iA = 0; iA < iB; iA++)
                    {
                        if (CumplePitagoras(iA, iB, iC) && (iA + iB + iC) == ValorSuma)
                        {
                            return iA * iB * iC;
                        }
                    }
                }
            }


            return 0;
        }

        static Boolean CumplePitagoras(int a, int b, int c)
        {
            return ((a * a) + (b * b) == (c * c));
        }

        #endregion

        #endregion

        #region Problemas 10 - 19

        #region Problema 10

        /*
         * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
         * 
         * Find the sum of all the primes below two million.
         */

        static long Problema10()
        {
            long CantMax = 2000000;



            return SumaValores(ObtenerPrimos(CantMax));

        }


        static List<long> ObtenerPrimos(long Max, Boolean UsarNegativos = false)
        {
            /*http://es.wikipedia.org/wiki/Criba_de_Erat%C3%B3stenes*/

            List<long> Numeros = new List<long>();

            Numeros.Add(2);

            for (int i = 3; i <= Max; i += 2)
            {
                Numeros.Add(i);
            }

            for (int i = 1; ; i++)
            {
                var NuevoPrimo = Numeros.ElementAt(i);
                //  NumPrimos.Add(NuevoPrimo);
                Numeros = Numeros.Where(p => p == NuevoPrimo || p % NuevoPrimo != 0).ToList();

                if (Exp(NuevoPrimo, 2) > Max)
                    break;
            }

            if (UsarNegativos)
            {
                List<long> NumerosNeg = new List<long>();
                for (int i = 0; i < Numeros.Count; i++)
                {
                    NumerosNeg.Add(-(Numeros.ElementAt(i)));
                }
                Numeros.AddRange(NumerosNeg);
            }

            return Numeros;
        }

        static long SumaValores(List<long> Numeros)
        {
            long SumaV = 0;

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += Numeros.ElementAt(i);
            }

            return SumaV;
        }


        static BigInteger SumaValores(List<BigInteger> Numeros)
        {
            BigInteger SumaV = 0;

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += Numeros.ElementAt(i);
            }

            return SumaV;
        }

        static long SumaValores(List<char> Numeros)
        {
            long SumaV = 0;

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += int.Parse(Numeros.ElementAt(i).ToString());
            }

            return SumaV;
        }

        static long SumaFactorialValores(List<char> Numeros, List<int> Fact0a9)
        {
            long SumaV = 0;

            // List<int> Fact_0a9 = ListaFact_0a9();

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += Fact0a9.ElementAt(int.Parse(Numeros.ElementAt(i).ToString()));
            }

            return SumaV;
        }

        static List<int> ListaFact_0a9()
        {
            List<int> Fac = new List<int>();

            for (int i = 0; i < 10; i++)
            {
                Fac.Add(int.Parse(Factorial(i).ToString()));
            }

            return Fac;
        }

        #endregion

        #region Problema 11

        /*
         * In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
         * 
         * 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
         * 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
         * 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
         * 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
         * 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
         * 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
         * 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
         * 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
         * 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
         * 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
         * 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
         * 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
         * 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
         * 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
         * 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
         * 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
         * 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
         * 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
         * 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
         * 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
         * 
         * The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
         * What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
         */


        static long Problema11()
        {
            List<List<int>> Numeros = new List<List<int>>() {
                                    new List<int>() {08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08},
                                    new List<int>() {49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00},
                                    new List<int>() {81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65},
                                    new List<int>() {52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91},
                                    new List<int>() {22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80},
                                    new List<int>() {24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50},
                                    new List<int>() {32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70},
                                    new List<int>() {67,26,20,68,02,62,12,20,95,63,94,39,63,08,40,91,66,49,94,21},
                                    new List<int>() {24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72},
                                    new List<int>() {21,36,23,09,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95},
                                    new List<int>() {78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,09,53,56,92},
                                    new List<int>() {16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57},
                                    new List<int>() {86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58},
                                    new List<int>() {19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40},
                                    new List<int>() {04,52,08,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66},
                                    new List<int>() {88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69},
                                    new List<int>() {04,42,16,73,38,25,39,11,24,94,72,18,08,46,29,32,40,62,76,36},
                                    new List<int>() {20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16},
                                    new List<int>() {20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54},
                                    new List<int>() {01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48}};

            List<List<int>> NumerosAgrup = AgruparNumero_TodasDir(Numeros, 4);





            return MaxMult(NumerosAgrup);
        }

        static List<List<int>> AgruparNumero_TodasDir(List<List<int>> ArrNumeros, int TamañoGrupo)
        {
            int TamañoArray = ArrNumeros.Count;

            List<List<int>> NumeroGrupo = new List<List<int>>();

            for (int iNumeros = 0; iNumeros < ArrNumeros.Count; iNumeros++)
            {
                List<int> Numeros = ArrNumeros[iNumeros];
                for (int i = 0; i < (Numeros.Count - TamañoGrupo) + 1; i++)
                {
                    NumeroGrupo.Add(Numeros.Sublist(i, TamañoGrupo));
                }
            }

            List<List<int>> ArrNumerosInv = InvertirLista(ArrNumeros);

            for (int iNumeros = 0; iNumeros < ArrNumerosInv.Count; iNumeros++)
            {
                List<int> Numeros = ArrNumerosInv[iNumeros];
                for (int i = 0; i < (Numeros.Count - TamañoGrupo) + 1; i++)
                {
                    NumeroGrupo.Add(Numeros.Sublist(i, TamañoGrupo));
                }
            }

            for (int iNumeros = 0; iNumeros < (TamañoArray - TamañoGrupo) + 1; iNumeros++)
            {
                for (int i = 0; i < (TamañoArray - TamañoGrupo) + 1; i++)
                {
                    List<int> NuevosNumeros = new List<int>();

                    NuevosNumeros.Add(ArrNumeros[iNumeros].ElementAt(i));
                    NuevosNumeros.Add(ArrNumeros[iNumeros + 1].ElementAt(i + 1));
                    NuevosNumeros.Add(ArrNumeros[iNumeros + 2].ElementAt(i + 2));
                    NuevosNumeros.Add(ArrNumeros[iNumeros + 3].ElementAt(i + 3));

                    NumeroGrupo.Add(NuevosNumeros);
                }
            }

            for (int iNumeros = 0; iNumeros < (TamañoArray - TamañoGrupo) + 1; iNumeros++)
            {
                for (int i = TamañoArray - 1; i >= (0 + TamañoGrupo); i--)
                {
                    List<int> NuevosNumeros = new List<int>();

                    NuevosNumeros.Add(ArrNumeros[iNumeros].ElementAt(i));
                    NuevosNumeros.Add(ArrNumeros[iNumeros + 1].ElementAt(i - 1));
                    NuevosNumeros.Add(ArrNumeros[iNumeros + 2].ElementAt(i - 2));
                    NuevosNumeros.Add(ArrNumeros[iNumeros + 3].ElementAt(i - 3));

                    NumeroGrupo.Add(NuevosNumeros);
                }
            }


            return NumeroGrupo;
        }

        static List<List<int>> InvertirLista(List<List<int>> Numeros)
        {
            List<List<int>> Resultado = new List<List<int>>();

            for (int i = 0; i < Numeros.Count; i++)
            {
                List<int> SubResultado = new List<int>();

                for (int j = 0; j < Numeros.ElementAt(i).Count; j++)
                {
                    SubResultado.Add(Numeros.ElementAt(j).ElementAt(i));
                }

                Resultado.Add(SubResultado);

            }

            return Resultado;
        }


        static List<int> Sublist(this List<int> Lista, int startIndex, int length)
        {
            List<int> resultado = new List<int>();

            for (int i = startIndex; i < (startIndex + length); i++)
            {
                resultado.Add(Lista.ElementAt(i));
            }

            return resultado;
        }

        static long MaxMult(List<List<int>> NumeroGrupo)
        {
            long Mult = 0;

            List<long> TodosMult = new List<long>();

            for (int ii = 0; ii < NumeroGrupo.Count; ii++)
            {

                long Resultado = 1;

                for (int iCar = 0; iCar < NumeroGrupo.ElementAt(ii).Count; iCar++)
                {
                    Resultado *= NumeroGrupo.ElementAt(ii).ElementAt(iCar);
                }

                Mult = Math.Max(Mult, Resultado);

                TodosMult.Add(Resultado);
            }

            //return Mult;
            return Max(TodosMult);
        }

        #endregion

        #region Problema 12

        /*
         * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
         * The first ten terms would be:
         *              1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
         * 
         * Let us list the factors of the first seven triangle numbers:
         * 
         * 
         * 1: 1
         * 3: 1,3
         * 6: 1,2,3,6
         * 10: 1,2,5,10
         * 15: 1,3,5,15
         * 21: 1,3,7,21
         * 28: 1,2,4,7,14,28
         * 
         * We can see that 28 is the first triangle number to have over five divisors.
         * What is the value of the first triangle number to have over five hundred divisors?
         */

        static long Problema12()
        {
            long Base = 12250;
            long SumaTriangulo = 1;

            do
            {
                long CantidadM = CantidadMultiplos(SumaTriangulo);

                if (CantidadM >= 500)
                {
                    break;
                }
                else
                {
                    Base++;
                    SumaTriangulo = (Base * (Base + 1)) / 2;
                }
            } while (true);

            return SumaTriangulo;
        }

        static long CantidadMultiplos(long Numero)
        {
            int Cantidad = 0;

            for (int i = 1; i <= Numero; i++)
            {
                if (Numero % i == 0)
                {
                    Cantidad++;
                }
            }

            return Cantidad;
        }

        #endregion

        #region Problema 13

        /*
         * Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
         * 
         *                              37107287533902102798797998220837590246510135740250
         *                              46376937677490009712648124896970078050417018260538
         *                              74324986199524741059474233309513058123726617309629
         *                              91942213363574161572522430563301811072406154908250
         *                              23067588207539346171171980310421047513778063246676
         *                              89261670696623633820136378418383684178734361726757
         *                              28112879812849979408065481931592621691275889832738
         *                              44274228917432520321923589422876796487670272189318
         *                              47451445736001306439091167216856844588711603153276
         *                              70386486105843025439939619828917593665686757934951
         *                              62176457141856560629502157223196586755079324193331
         *                              64906352462741904929101432445813822663347944758178
         *                              92575867718337217661963751590579239728245598838407
         *                              58203565325359399008402633568948830189458628227828
         *                              80181199384826282014278194139940567587151170094390
         *                              35398664372827112653829987240784473053190104293586
         *                              86515506006295864861532075273371959191420517255829
         *                              71693888707715466499115593487603532921714970056938
         *                              54370070576826684624621495650076471787294438377604
         *                              53282654108756828443191190634694037855217779295145
         *                              36123272525000296071075082563815656710885258350721
         *                              45876576172410976447339110607218265236877223636045
         *                              17423706905851860660448207621209813287860733969412
         *                              81142660418086830619328460811191061556940512689692
         *                              51934325451728388641918047049293215058642563049483
         *                              62467221648435076201727918039944693004732956340691
         *                              15732444386908125794514089057706229429197107928209
         *                              55037687525678773091862540744969844508330393682126
         *                              18336384825330154686196124348767681297534375946515
         *                              80386287592878490201521685554828717201219257766954
         *                              78182833757993103614740356856449095527097864797581
         *                              16726320100436897842553539920931837441497806860984
         *                              48403098129077791799088218795327364475675590848030
         *                              87086987551392711854517078544161852424320693150332
         *                              59959406895756536782107074926966537676326235447210
         *                              69793950679652694742597709739166693763042633987085
         *                              41052684708299085211399427365734116182760315001271
         *                              65378607361501080857009149939512557028198746004375
         *                              35829035317434717326932123578154982629742552737307
         *                              94953759765105305946966067683156574377167401875275
         *                              88902802571733229619176668713819931811048770190271
         *                              25267680276078003013678680992525463401061632866526
         *                              36270218540497705585629946580636237993140746255962
         *                              24074486908231174977792365466257246923322810917141
         *                              91430288197103288597806669760892938638285025333403
         *                              34413065578016127815921815005561868836468420090470
         *                              23053081172816430487623791969842487255036638784583
         *                              11487696932154902810424020138335124462181441773470
         *                              63783299490636259666498587618221225225512486764533
         *                              67720186971698544312419572409913959008952310058822
         *                              95548255300263520781532296796249481641953868218774
         *                              76085327132285723110424803456124867697064507995236
         *                              37774242535411291684276865538926205024910326572967
         *                              23701913275725675285653248258265463092207058596522
         *                              29798860272258331913126375147341994889534765745501
         *                              18495701454879288984856827726077713721403798879715
         *                              38298203783031473527721580348144513491373226651381
         *                              34829543829199918180278916522431027392251122869539
         *                              40957953066405232632538044100059654939159879593635
         *                              29746152185502371307642255121183693803580388584903
         *                              41698116222072977186158236678424689157993532961922
         *                              62467957194401269043877107275048102390895523597457
         *                              23189706772547915061505504953922979530901129967519
         *                              86188088225875314529584099251203829009407770775672
         *                              11306739708304724483816533873502340845647058077308
         *                              82959174767140363198008187129011875491310547126581
         *                              97623331044818386269515456334926366572897563400500
         *                              42846280183517070527831839425882145521227251250327
         *                              55121603546981200581762165212827652751691296897789
         *                              32238195734329339946437501907836945765883352399886
         *                              75506164965184775180738168837861091527357929701337
         *                              62177842752192623401942399639168044983993173312731
         *                              32924185707147349566916674687634660915035914677504
         *                              99518671430235219628894890102423325116913619626622
         *                              73267460800591547471830798392868535206946944540724
         *                              76841822524674417161514036427982273348055556214818
         *                              97142617910342598647204516893989422179826088076852
         *                              87783646182799346313767754307809363333018982642090
         *                              10848802521674670883215120185883543223812876952786
         *                              71329612474782464538636993009049310363619763878039
         *                              62184073572399794223406235393808339651327408011116
         *                              66627891981488087797941876876144230030984490851411
         *                              60661826293682836764744779239180335110989069790714
         *                              85786944089552990653640447425576083659976645795096
         *                              66024396409905389607120198219976047599490197230297
         *                              64913982680032973156037120041377903785566085089252
         *                              16730939319872750275468906903707539413042652315011
         *                              94809377245048795150954100921645863754710598436791
         *                              78639167021187492431995700641917969777599028300699
         *                              15368713711936614952811305876380278410754449733078
         *                              40789923115535562561142322423255033685442488917353
         *                              44889911501440648020369068063960672322193204149535
         *                              41503128880339536053299340368006977710650566631954
         *                              81234880673210146739058568557934581403627822703280
         *                              82616570773948327592232845941706525094512325230608
         *                              22918802058777319719839450180888072429661980811197
         *                              77158542502016545090413245809786882778948721859617
         *                              72107838435069186155435662884062257473692284509516
         *                              20849603980134001723930671666823555245252804609722
         *                              53503534226472524250874054075591789781264330331690
         */

        static string Problema13()
        {
            #region ListNumeros
            List<BigInteger> ListNumeros = new List<BigInteger>() {
                BigInteger.Parse("37107287533902102798797998220837590246510135740250"),
                BigInteger.Parse("46376937677490009712648124896970078050417018260538"),
                BigInteger.Parse("74324986199524741059474233309513058123726617309629"),
                BigInteger.Parse("91942213363574161572522430563301811072406154908250"),
                BigInteger.Parse("23067588207539346171171980310421047513778063246676"),
                BigInteger.Parse("89261670696623633820136378418383684178734361726757"),
                BigInteger.Parse("28112879812849979408065481931592621691275889832738"),
                BigInteger.Parse("44274228917432520321923589422876796487670272189318"),
                BigInteger.Parse("47451445736001306439091167216856844588711603153276"),
                BigInteger.Parse("70386486105843025439939619828917593665686757934951"),
                BigInteger.Parse("62176457141856560629502157223196586755079324193331"),
                BigInteger.Parse("64906352462741904929101432445813822663347944758178"),
                BigInteger.Parse("92575867718337217661963751590579239728245598838407"),
                BigInteger.Parse("58203565325359399008402633568948830189458628227828"),
                BigInteger.Parse("80181199384826282014278194139940567587151170094390"),
                BigInteger.Parse("35398664372827112653829987240784473053190104293586"),
                BigInteger.Parse("86515506006295864861532075273371959191420517255829"),
                BigInteger.Parse("71693888707715466499115593487603532921714970056938"),
                BigInteger.Parse("54370070576826684624621495650076471787294438377604"),
                BigInteger.Parse("53282654108756828443191190634694037855217779295145"),
                BigInteger.Parse("36123272525000296071075082563815656710885258350721"),
                BigInteger.Parse("45876576172410976447339110607218265236877223636045"),
                BigInteger.Parse("17423706905851860660448207621209813287860733969412"),
                BigInteger.Parse("81142660418086830619328460811191061556940512689692"),
                BigInteger.Parse("51934325451728388641918047049293215058642563049483"),
                BigInteger.Parse("62467221648435076201727918039944693004732956340691"),
                BigInteger.Parse("15732444386908125794514089057706229429197107928209"),
                BigInteger.Parse("55037687525678773091862540744969844508330393682126"),
                BigInteger.Parse("18336384825330154686196124348767681297534375946515"),
                BigInteger.Parse("80386287592878490201521685554828717201219257766954"),
                BigInteger.Parse("78182833757993103614740356856449095527097864797581"),
                BigInteger.Parse("16726320100436897842553539920931837441497806860984"),
                BigInteger.Parse("48403098129077791799088218795327364475675590848030"),
                BigInteger.Parse("87086987551392711854517078544161852424320693150332"),
                BigInteger.Parse("59959406895756536782107074926966537676326235447210"),
                BigInteger.Parse("69793950679652694742597709739166693763042633987085"),
                BigInteger.Parse("41052684708299085211399427365734116182760315001271"),
                BigInteger.Parse("65378607361501080857009149939512557028198746004375"),
                BigInteger.Parse("35829035317434717326932123578154982629742552737307"),
                BigInteger.Parse("94953759765105305946966067683156574377167401875275"),
                BigInteger.Parse("88902802571733229619176668713819931811048770190271"),
                BigInteger.Parse("25267680276078003013678680992525463401061632866526"),
                BigInteger.Parse("36270218540497705585629946580636237993140746255962"),
                BigInteger.Parse("24074486908231174977792365466257246923322810917141"),
                BigInteger.Parse("91430288197103288597806669760892938638285025333403"),
                BigInteger.Parse("34413065578016127815921815005561868836468420090470"),
                BigInteger.Parse("23053081172816430487623791969842487255036638784583"),
                BigInteger.Parse("11487696932154902810424020138335124462181441773470"),
                BigInteger.Parse("63783299490636259666498587618221225225512486764533"),
                BigInteger.Parse("67720186971698544312419572409913959008952310058822"),
                BigInteger.Parse("95548255300263520781532296796249481641953868218774"),
                BigInteger.Parse("76085327132285723110424803456124867697064507995236"),
                BigInteger.Parse("37774242535411291684276865538926205024910326572967"),
                BigInteger.Parse("23701913275725675285653248258265463092207058596522"),
                BigInteger.Parse("29798860272258331913126375147341994889534765745501"),
                BigInteger.Parse("18495701454879288984856827726077713721403798879715"),
                BigInteger.Parse("38298203783031473527721580348144513491373226651381"),
                BigInteger.Parse("34829543829199918180278916522431027392251122869539"),
                BigInteger.Parse("40957953066405232632538044100059654939159879593635"),
                BigInteger.Parse("29746152185502371307642255121183693803580388584903"),
                BigInteger.Parse("41698116222072977186158236678424689157993532961922"),
                BigInteger.Parse("62467957194401269043877107275048102390895523597457"),
                BigInteger.Parse("23189706772547915061505504953922979530901129967519"),
                BigInteger.Parse("86188088225875314529584099251203829009407770775672"),
                BigInteger.Parse("11306739708304724483816533873502340845647058077308"),
                BigInteger.Parse("82959174767140363198008187129011875491310547126581"),
                BigInteger.Parse("97623331044818386269515456334926366572897563400500"),
                BigInteger.Parse("42846280183517070527831839425882145521227251250327"),
                BigInteger.Parse("55121603546981200581762165212827652751691296897789"),
                BigInteger.Parse("32238195734329339946437501907836945765883352399886"),
                BigInteger.Parse("75506164965184775180738168837861091527357929701337"),
                BigInteger.Parse("62177842752192623401942399639168044983993173312731"),
                BigInteger.Parse("32924185707147349566916674687634660915035914677504"),
                BigInteger.Parse("99518671430235219628894890102423325116913619626622"),
                BigInteger.Parse("73267460800591547471830798392868535206946944540724"),
                BigInteger.Parse("76841822524674417161514036427982273348055556214818"),
                BigInteger.Parse("97142617910342598647204516893989422179826088076852"),
                BigInteger.Parse("87783646182799346313767754307809363333018982642090"),
                BigInteger.Parse("10848802521674670883215120185883543223812876952786"),
                BigInteger.Parse("71329612474782464538636993009049310363619763878039"),
                BigInteger.Parse("62184073572399794223406235393808339651327408011116"),
                BigInteger.Parse("66627891981488087797941876876144230030984490851411"),
                BigInteger.Parse("60661826293682836764744779239180335110989069790714"),
                BigInteger.Parse("85786944089552990653640447425576083659976645795096"),
                BigInteger.Parse("66024396409905389607120198219976047599490197230297"),
                BigInteger.Parse("64913982680032973156037120041377903785566085089252"),
                BigInteger.Parse("16730939319872750275468906903707539413042652315011"),
                BigInteger.Parse("94809377245048795150954100921645863754710598436791"),
                BigInteger.Parse("78639167021187492431995700641917969777599028300699"),
                BigInteger.Parse("15368713711936614952811305876380278410754449733078"),
                BigInteger.Parse("40789923115535562561142322423255033685442488917353"),
                BigInteger.Parse("44889911501440648020369068063960672322193204149535"),
                BigInteger.Parse("41503128880339536053299340368006977710650566631954"),
                BigInteger.Parse("81234880673210146739058568557934581403627822703280"),
                BigInteger.Parse("82616570773948327592232845941706525094512325230608"),
                BigInteger.Parse("22918802058777319719839450180888072429661980811197"),
                BigInteger.Parse("77158542502016545090413245809786882778948721859617"),
                BigInteger.Parse("72107838435069186155435662884062257473692284509516"),
                BigInteger.Parse("20849603980134001723930671666823555245252804609722"),
                BigInteger.Parse("53503534226472524250874054075591789781264330331690")};
            #endregion

            BigInteger Resultado = SumaLista(ListNumeros);

            string Primeros10 = Resultado.ToString().Substring(0, 10);

            return Primeros10;
        }

        static BigInteger SumaLista(List<BigInteger> Lista)
        {
            BigInteger Resultado = 0;

            for (int i = 0; i < Lista.Count; i++)
            {
                Resultado += Lista.ElementAt(i);
            }

            return Resultado;

        }

        static BigInteger SumaLista(List<int> Lista)
        {
            BigInteger Resultado = 0;

            for (int i = 0; i < Lista.Count; i++)
            {
                Resultado += Lista.ElementAt(i);
            }

            return Resultado;

        }

        static BigInteger SumaLista(List<long> Lista)
        {
            BigInteger Resultado = 0;

            for (int i = 0; i < Lista.Count; i++)
            {
                Resultado += Lista.ElementAt(i);
            }

            return Resultado;

        }

        #endregion

        #region Problema 14

        /*
         * The following iterative sequence is defined for the set of positive integers:
         *          n → n/2 (n is even)
         *          n → 3n + 1 (n is odd)
         *
         * Using the rule above and starting with 13, we generate the following sequence:
         *
         *          13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
         *          
         * It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), 
         * it is thought that all starting numbers finish at 1.
         * 
         * Which starting number, under one million, produces the longest chain?
         * 
         * NOTE: Once the chain starts the terms are allowed to go above one million.
         */


        static long Problema14()
        {
            long Resultado = 0;

            long TamañoSeqMax = 0;

            for (int i = 999999; i > 0; i--)
            {
                //TamañoSeqMax = Math.Max(TamañoSeq(i), TamañoSeqMax);

                if (TamañoSeq(i) > TamañoSeqMax)
                {
                    TamañoSeqMax = TamañoSeq(i);
                    Resultado = i;
                }
            }


            return Resultado;

        }

        static long TamañoSeq(long Valor)
        {
            long Cantidad = 0;
            long NuevoValor = Valor;

            while (true)
            {
                NuevoValor = ValorSigiente(NuevoValor);
                Cantidad++;
                if (NuevoValor <= 1)
                {
                    break;
                }
            }

            return Cantidad;
        }

        static long ValorSigiente(long Valor)
        {
            return ((Valor % 2) == 0) ? (Valor / 2) : ((Valor * 3) + 1);
        }


        #endregion

        #region Problema 15

        /*
         * Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
         * 
         * D = Derecha y A = Abajo
         * 
         * DDAA     DADA    DAAD    ADDA    ADAD    AADD
         * 
         * How many such routes are there through a 20×20 grid?
         */

        static BigInteger Problema15()
        {
            int TamañoGrilla = 20;

            BigInteger Resultado = 0;


            Resultado = Combinatoria(TamañoGrilla * 2, TamañoGrilla);

            return Resultado;
        }

        static BigInteger Combinatoria(int CantElemento, int CantSubConjunto)
        {
            BigInteger Res = 0;

            Res = Factorial(CantElemento) / (Factorial(CantSubConjunto) * Factorial(CantElemento - CantSubConjunto));

            return Res;
        }

        static BigInteger Factorial(int Numero)
        {
            BigInteger Res = 1;

            for (int i = 1; i <= Numero; i++)
            {
                Res *= i;
            }

            return Res;
        }

        #endregion

        #region Problema 16

        /*
         * 215 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
         * 
         * What is the sum of the digits of the number 21000?
         */

        static BigInteger Problema16()
        {
            BigInteger Resultado = 0;

            var ResultadoExp = Exp(2, 1000);

            Resultado = SumaDigitos(ResultadoExp);

            return Resultado;
        }

        static BigInteger Exp(int Base, int Exp)
        {
            BigInteger Res = 1;

            for (int i = 1; i <= Exp; i++)
            {
                Res *= Base;
            }

            return Res;
        }

        static decimal Exp(decimal Base, decimal Exp)
        {
            decimal Res = 1;

            for (int i = 1; i <= Exp; i++)
            {
                Res *= Base;
            }

            return Res;
        }

        static decimal Exp(long Base, long Exp)
        {
            decimal Res = 1;

            for (int i = 1; i <= Exp; i++)
            {
                Res *= Base;
            }

            return Res;
        }

        //static BigInteger Exp_BigInteger(decimal Base, decimal Exp)
        //{
        //    decimal Res = 1;

        //    for (int i = 1; i <= Exp; i++)
        //    {
        //        Res *= Base;
        //    }

        //    return (BigInteger)Res;
        //}

        static double Exp(double Base, double Exp)
        {
            double Res = 1;

            for (int i = 1; i <= Exp; i++)
            {
                Res *= Base;
            }

            return Res;
        }

        static BigInteger Exp(int Base, BigInteger Exp)
        {
            BigInteger Res = 1;

            for (BigInteger i = 1; i <= Exp; i++)
            {
                Res *= Base;
            }

            return Res;
        }

        static BigInteger SumaDigitos(BigInteger Numero, long Exp)
        {
            BigInteger Res = 0;

            var S_Numero = Numero.ToString();

            var List_S_Numero = S_Numero.ToCharArray().ToList();

            Res = SumaValores(List_S_Numero, Exp);

            return Res;
        }

        static BigInteger SumaFactorialDigitos(BigInteger Numero, List<int> Fact0a9)
        {
            BigInteger Res = 0;

            var S_Numero = Numero.ToString();

            var List_S_Numero = S_Numero.ToCharArray().ToList();

            Res = SumaFactorialValores(List_S_Numero, Fact0a9);

            return Res;
        }



        static long SumaValores(List<char> Numeros, long Exp)
        {
            long SumaV = 0;

            for (int i = 0; i < Numeros.Count; i++)
            {
                SumaV += (long)Math.Pow(int.Parse(Numeros.ElementAt(i).ToString()), Exp);
            }

            return SumaV;
        }

        #endregion

        #region Problema 17

        /*
         * If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
         * 
         * If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
         * 
         * NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. 
         * The use of "and" when writing out numbers is in compliance with British usage.
         */

        #endregion

        #region Problema 18

        /*
         * By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
         *
         *                                     3
         *                                    7 4
         *                                   2 4 6
         *                                  8 5 9 3
         *
         *  That is, 3 + 7 + 4 + 9 = 23.
         *  
         * Find the maximum total from top to bottom of the triangle below:

         *                                75
         *                              95 64
         *                             17 47 82
         *                           18 35 87 10
         *                         20 04 82 47 65
         *                        19 01 23 75 03 34
         *                      88 02 77 73 07 63 67
         *                     99 65 04 28 06 16 70 92
         *                   41 41 26 56 83 40 80 70 33
         *                  41 48 72 33 47 32 37 16 94 29
         *                53 71 44 65 25 43 91 52 97 51 14
         *               70 11 33 28 77 73 17 78 39 68 17 57
         *             91 71 52 38 17 14 91 43 58 50 27 29 48
         *            63 66 04 68 89 53 67 30 73 16 69 87 40 31 
         *          04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
         *
         * NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route.
         * However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)
         */


        /*
           //var A = new QuickGraph.AdjacencyGraph<Dato, QuickGraph.Edge<Dato>>();

            //var DatoV1 = new Dato() { valor = 41 };
            //var DatoV2 = new Dato() { valor = 41 };
            //var DatoV3 = new Dato() { valor = 41 };

            //A.AddVertex(DatoV1);
            //A.AddVertex(DatoV2);
            //A.AddVertex(DatoV3);

            //A.AddEdge(new Edge<Dato>(DatoV1, DatoV2));
            //A.AddEdge(new Edge<Dato>(DatoV1, DatoV3));
         
         */


        static long Problema18()
        {
            long Resultado = 0;


            List<List<string>> ListaNumeros_S = LeerArchivo("Archivos\\Triangulo1.txt", ' ');

            Resultado = CalcMax(ListaNumeros_S);


            return Resultado;
        }

        class Dato
        {
            public int valor { get; set; }
        }

        static List<List<string>> LeerArchivo(string Ruta, params char[] Separador)
        {
            List<List<string>> ListaNum = new List<List<string>>();

            StreamReader Archivo = new StreamReader(Ruta);

            string Linea = "";

            do
            {
                Linea = Archivo.ReadLine();

                if (Linea != null)
                {
                    ListaNum.Add(Linea.Split(Separador).ToList());
                }
                else
                {
                    break;
                }

            } while (true);



            return ListaNum;
        }

        static long CalcMax(List<List<string>> Lista)
        {
            int Count = Lista.Count;

            for (int L = Count; L > 1; L--)
            {
                List<string> Ultima = Lista.ElementAt(L - 1);
                List<string> AnteUltima = Lista.ElementAt(L - 2);
                List<string> Caminos = new List<string>();

                for (int LL = 0; LL < AnteUltima.Count; LL++)
                {
                    int Camino1 = int.Parse(AnteUltima.ElementAt(LL)) + int.Parse(Ultima.ElementAt(LL));
                    int Camino2 = int.Parse(AnteUltima.ElementAt(LL)) + int.Parse(Ultima.ElementAt(LL + 1));

                    int Camino = Math.Max(Camino1, Camino2);

                    Caminos.Add(Camino.ToString());

                }

                Lista.Remove(Ultima);
                Lista.Remove(AnteUltima);

                Lista.Add(Caminos);
            }

            return long.Parse(Lista.FirstOrDefault().FirstOrDefault());
        }

        #endregion

        #region Problema 19

        /*
         * You are given the following information, but you may prefer to do some research for yourself.
         *      
         *        + 1 Jan 1900 was a Monday.
         *        + Thirty days has September,
         *          April, June and November.
         *          All the rest have thirty-one,
         *          Saving February alone,
         *          Which has twenty-eight, rain or shine.
         *          And on leap years, twenty-nine.
         *        + A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
         *
         * How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
         */

        static int Problema19()
        {
            int Resultado = 0;

            string DiaSemana = "Sunday";
            int DiaMes = 1;

            DateTime Inicio = new DateTime(1901, 01, 01);
            DateTime Fin = new DateTime(2000, 12, 31);

            Resultado = ContarDias(DiaSemana, DiaMes, Inicio, Fin);

            return Resultado;
        }

        private static int ContarDias(string DiaSemana, int DiaMes, DateTime Inicio, DateTime Fin)
        {
            int Cantidad = 0;
            DateTime FechasTmp = new DateTime(Inicio.Ticks);

            while (FechasTmp > Inicio && FechasTmp < Fin)
            {
                if ((FechasTmp.DayOfWeek.ToString().Equals(DiaSemana)) && (FechasTmp.Day == DiaMes))
                {
                    Cantidad++;
                }
                FechasTmp = FechasTmp.AddDays(1);
            }

            return Cantidad;
        }

        #endregion

        #endregion

        #region Problemas 20 - 29

        #region Problema 20

        /*
         * n! means n × (n − 1) × ... × 3 × 2 × 1
         * 
         * For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
         * and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
         * 
         * Find the sum of the digits in the number 100!
         */

        static BigInteger Problema20()
        {
            BigInteger Resultado = 0;

            Resultado = SumaDigitos(Factorial(100));

            return Resultado;
        }

        #endregion

        #region Problema 21

        /*Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
         * If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
         * 
         * For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. 
         * The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
         * 
         * Evaluate the sum of all the amicable numbers under 10000.
         */

        static BigInteger Problema21()
        {
            BigInteger Resultado = 0;

            List<BigInteger> NumerosAmigos = new List<BigInteger>();

            int Maximo = 10000;

            NumerosAmigos = CalAmigosFB(Maximo);

            Resultado = SumaValores(NumerosAmigos);


            return Resultado;
        }

        private static List<BigInteger> CalAmigosFB(int Maximo)
        {
            List<BigInteger> NumerosAmigos = new List<BigInteger>();

            for (long n = 1; n < Maximo; n++)
            {
                long a = n;
                long b = SumaValores(Factores(a, false)); ;
                var Sumb = SumaValores(Factores(b, false));

                if (b > a && Sumb == a)
                {
                    NumerosAmigos.Add(a);
                    NumerosAmigos.Add(b);
                }
            }


            return NumerosAmigos;
        }

        private static List<BigInteger> CalAmigosFormula(int Maximo)
        {
            List<BigInteger> NumerosAmigos = new List<BigInteger>();

            for (int n = 2; true; n++)
            {
                BigInteger p = 3 * Exp(2, n - 1) - 1;
                BigInteger q = 3 * Exp(2, n) - 1;
                BigInteger r = 9 * Exp(2, 2 * n - 1) - 1;

                if (EsPrimo(p) && EsPrimo(q) && EsPrimo(r))
                {
                    BigInteger NumTmp = Exp(2, n);
                    BigInteger NumA1 = NumTmp * p * q;
                    BigInteger NumA2 = NumTmp * r;

                    if (NumA1 < Maximo)
                    {
                        NumerosAmigos.Add(NumA1);
                    }

                    if (NumA2 < Maximo)
                    {
                        NumerosAmigos.Add(NumA2);
                    }

                    if (NumA1 >= Maximo || NumA2 >= Maximo)
                    {
                        break;
                    }

                }
            }

            return NumerosAmigos;
        }

        #endregion

        #region Problema 22

        /*
         * Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. 
         * Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
         * 
         * For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. 
         * So, COLIN would obtain a score of 938 × 53 = 49714.
         * 
         * What is the total of all the name scores in the file?
         */

        static BigInteger Problema22()
        {
            BigInteger Resultado = 0;

            List<string> ListaNombres = LeerArchivo("Archivos\\names.txt", ',').First().RemoveInValues('\"');

            ListaNombres.Sort();

            Resultado = CalcularValorNombres(ListaNombres);

            return Resultado;
        }

        static long CalcularValorNombres(List<string> ListaNombres)
        {
            long Valor = 0;

            for (int i = 0; i < ListaNombres.Count; i++)
            {
                Valor += CalcularValorPalabra(ListaNombres.ElementAt(i)) * (i + 1);
            }

            return Valor;
        }

        static int CalcularValorLetra(char Letra)
        {
            List<char> ABCd = " abcdefghijklmnopqrstuvwxyz".ToCharArray().ToList();

            int Valor = ABCd.IndexOf(Letra.ToLower());

            return Valor;
        }

        static int CalcularValorPalabra(string Palabra)
        {
            int Valor = 0;

            for (int i = 0; i < Palabra.Length; i++)
            {
                Valor += CalcularValorLetra(Palabra[i]);
            }

            return Valor;
        }


        static List<string> RemoveInValues(this List<string> Lista, params char[] charRemove)
        {
            List<string> ListResult = new List<string>();

            for (int i = 0; i < Lista.Count; i++)
            {
                ListResult.Add(Lista.ElementAt(i).RemoveChars(charRemove));
            }

            return ListResult;
        }
        #endregion

        #region Problema 23

        /*
         * A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. 
         * For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
         * 
         * A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
         * 
         * As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. 
         * By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.
         * 
         * However, this upper limit cannot be reduced any further by analysis even though it is known that 
         * the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
         * 
         * Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.         * 
         */

        static long Problema23()
        {
            long Resultado = 0;

            long Limite = 28123;

            List<long> Lista = new List<long>();

            List<long> NumerosAbundanteslist = NumerosAbundantes(Limite);

            for (int i = 0; i <= Limite; i++)
            {
                if (!SePuedeFormarPorAbundantes(NumerosAbundanteslist, i))
                {
                    Lista.Add(i);
                }
            }

            Resultado = SumaValores(Lista);

            return Resultado;

        }

        static Boolean SePuedeFormarPorAbundantes(List<long> NumerosAbundanteslist, int Numero)
        {
            for (int ixAbund = 0; ixAbund < NumerosAbundanteslist.Count; ixAbund++)
            {
                long Abund = NumerosAbundanteslist.ElementAt(ixAbund);
                if (Numero < Abund)
                {
                    break;
                }
                else
                {
                    if (EsAbundante(Numero - Abund))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        static List<long> NumerosAbundantes(long Limite)
        {
            List<long> Lista = new List<long>();

            for (long i = 0; i <= Limite; i++)
            {
                if (EsAbundante(i))
                {
                    Lista.Add(i);
                }
            }

            return Lista;
        }

        static Boolean CantFactoresAbundantes()
        {
            return false;
        }

        static Boolean EsAbundante(long Numero)
        {
            long Suma = SumaValores(Factores(Numero, false));

            return Suma > (Numero);
        }

        #endregion

        #region Problema 24

        /*A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. 
         * If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:
         * 
         *              012   021   102   120   201   210
         * 
         * What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
         */

        static long Problema24()
        {
            long Resultado = 0;

            int IdOrden = 1000000;

            List<int> ListaEnteros = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

            List<string> ListaPermutaciones = Permutaciones(ListaEnteros);

            ListaPermutaciones.Sort();

            var tmp = ListaPermutaciones.ElementAt(IdOrden - 1);

            Resultado = long.Parse(tmp);

            return Resultado;
        }

        static List<string> Permutaciones(List<int> ListaEnteros)
        {
            List<string> ResListaEnteros = new List<string>();

            if (ListaEnteros.Count == 1)
            {
                ResListaEnteros.Add(ListaEnteros.FirstOrDefault().ToString());
            }
            else
            {


                for (int iNumInicio = 0; iNumInicio < ListaEnteros.Count; iNumInicio++)
                {
                    int ValorInicio = ListaEnteros.ElementAt(iNumInicio);

                    int[] ListaEnterostmp_Arr = new int[ListaEnteros.Count];
                    ListaEnteros.CopyTo(ListaEnterostmp_Arr);
                    List<int> ListaEnterostmp = ListaEnterostmp_Arr.ToList();

                    ListaEnterostmp.Remove(ValorInicio);

                    List<string> ListaPermut = Permutaciones(ListaEnterostmp);

                    for (int ii = 0; ii < ListaPermut.Count; ii++)
                    {
                        string tmp = ValorInicio.ToString() + ListaPermut.ElementAt(ii).ToString();
                        ResListaEnteros.Add(tmp);
                        //ResListaEnteros.Add(int.Parse(tmp));
                    }
                }
            }


            ResListaEnteros = ResListaEnteros.Distinct().ToList();

            return ResListaEnteros;
        }


        #endregion

        #region Problema 25

        /*PENDIENTE*/

        /*
         * The Fibonacci sequence is defined by the recurrence relation:
         * 
         *      Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
         * 
         * Hence the first 12 terms will be:
         * 
         *      F1 = 1
         *      F2 = 1
         *      F3 = 2
         *      F4 = 3
         *      F5 = 5
         *      F6 = 8
         *      F7 = 13
         *      F8 = 21
         *      F9 = 34
         *      F10 = 55
         *      F11 = 89
         *      F12 = 144
         *      
         * The 12th term, F12, is the first term to contain three digits.
         * 
         * What is the first term in the Fibonacci sequence to contain 1000 digits?
         */

        static BigInteger Problema25()
        {
            BigInteger Resultado = 0;


            Resultado = Nro_Termino_Fibonacci_x_DigitoMax(1000);

            return Resultado;
        }

        static BigInteger Nro_Termino_Fibonacci_x_ResultadoMax(Decimal ResultadoMax)
        {
            for (int i = 0; true; i++)
            {
                Decimal fTMP = Fibonacci(i);

                if (fTMP >= ResultadoMax)
                {
                    return i + 1;
                }
            }
        }

        static BigInteger Nro_Termino_Fibonacci_x_DigitoMax(BigInteger DigitoMaxMax)
        {
            for (int i = 0; true; i++)
            {
                Decimal fTMP = Fibonacci(i);

                if (fTMP.ToString().Length >= DigitoMaxMax)
                {
                    return i;
                }
            }
        }

        #endregion

        #region Problema 26

        /*
         * A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
         * 
         *      1/2	= 	0.5
         *      1/3	= 	0.(3)
         *      1/4	= 	0.25
         *      1/5	= 	0.2
         *      1/6	= 	0.1(6)
         *      1/7	= 	0.(142857)
         *      1/8	= 	0.125
         *      1/9	= 	0.(1)
         *      1/10	= 	0.1
         *      
         * Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
         * 
         * Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
         */

        static int Problema26()
        {
            int Resultado = 0;

            int Uno = 1;

            int CantDig = 0;

            for (int i = 1000; i > 1; i--)
            {
                int CantDigTmp = CantDigitosPeriodo(Uno, i);

                if (CantDig < CantDigTmp)
                {
                    CantDig = CantDigTmp;
                    Resultado = i;
                }
            }


            return Resultado;
        }

        static int CantDigitosPeriodo(int Numerador, int Denominador)
        {
            List<int> Restos = new List<int>();

            if (Numerador % Denominador == 0)
            {
                return 0;
            }
            else
            {
                int Entero = Numerador / Denominador;


                int Resto = Numerador - Entero * Denominador;

                Restos.Add(Resto);
                int RestoTmp = Resto;

                for (int i = 0; ; i++)
                {
                    int NumeradorTmp = RestoTmp * 10;
                    if (NumeradorTmp % Denominador == 0)
                    {
                        return 0;
                    }

                    RestoTmp = NumeradorTmp - (NumeradorTmp / Denominador) * Denominador;

                    if (Restos.Contains(RestoTmp))
                    {
                        int Ubicacion = Restos.IndexOf(RestoTmp);
                        return Restos.Count - Ubicacion;
                    }
                    else
                    {
                        Restos.Add(RestoTmp);
                    }
                }
            }
        }


        #endregion

        #region Problema 27

        /*
         * Euler discovered the remarkable quadratic formula:
         *          n² + n + 41
         *          
         * It turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39. 
         * However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible by 41.
         * 
         * The incredible formula  n² − 79n + 1601 was discovered, which produces 80 primes for the consecutive values n = 0 to 79. 
         * The product of the coefficients, −79 and 1601, is −126479.
         * 
         * Considering quadratics of the form:
         * 
         *          n² + an + b, where |a| < 1000 and |b| < 1000
         *          
         * where |n| is the modulus/absolute value of n
         * e.g. |11| = 11 and |−4| = 4
         * 
         * Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.
         */


        static long Problema27()
        {
            long Resultado = 0;

            long A;
            long B;
            long Max;

            Max = MaximaSecuencia(out A, out B);

            Resultado = A * B;

            return Resultado;
        }

        static long MaximaSecuencia(out long outA, out long outB)
        {
            long Maxima = 0;
            outA = 0;
            outB = 0;

            List<long> PrimosTodos = ObtenerPrimos(1000000);
            List<long> B_Primos = ObtenerPrimos(1000, true);

            for (int A = -999; A <= 1000; A += 2)
            {
                for (int indexB = 0; indexB < B_Primos.Count(); indexB++)
                {
                    long TamSeq = NroSecuenciaPrimos(PrimosTodos, A, B_Primos.ElementAt(indexB));

                    if (Maxima < TamSeq)
                    {
                        outA = A;
                        outB = B_Primos.ElementAt(indexB);
                        Maxima = TamSeq;
                    }
                }
            }

            return Maxima;
        }

        static long NroSecuenciaPrimos(List<long> PrimosTodos, long A, long B)
        {
            for (long n = 0; ; n++)
            {
                if (!PrimosTodos.Contains(FormulaCuadrada(n, A, B)))
                {
                    return n - 1;
                }
            }
        }

        static long FormulaCuadrada(long n, long a, long b)
        {
            return (long.Parse(Exp(n, 2).ToString()) + a * n + b);
        }

        #endregion

        #region Problema 28

        /*
         * Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
         * 
         *          21 22 23 24 25
         *          20  7  8  9 10
         *          19  6  1  2 11
         *          18  5  4  3 12
         *          17 16 15 14 13
         *          
         * It can be verified that the sum of the numbers on the diagonals is 101.
         * 
         * What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
         */

        static long Problema28()
        {
            long Resultado = 0;

            int Max = 1001;

            var L_IndexDiagonal = ListaIndexDiagonal(Max);

            Resultado = SumaDiagonal(L_IndexDiagonal);

            return Resultado;
        }

        static List<long> ListaIndexDiagonal(long Length)
        {
            List<long> Res = new List<long>();

            long Index = 0;
            Res.Add(Index);

            for (int i = 1; ; i++)
            {
                for (int m = 0; m < 4; m++)
                {
                    Index += (2 * i);
                    Res.Add(Index);
                }

                if (Index >= (Length * Length) - 1)
                {
                    break;
                }
            }

            return Res;
        }

        static long SumaDiagonal(List<long> ListaIndexDiagonal)
        {
            long Res = 0;

            for (int i = 0; i < ListaIndexDiagonal.Count; i++)
            {
                Res += (int)ListaIndexDiagonal.ElementAt(i) + 1;
            }


            return Res;
        }

        #endregion

        #region Problema 29

        /*
         * Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
         * 
         *      2^2=4, 2^3=8, 2^4=16, 2^5=32
         *      3^2=9, 3^3=27, 3^4=81, 3^5=243
         *      4^2=16, 4^3=64, 4^4=256, 4^5=1024
         *      5^2=25, 5^3=125, 5^4=625, 5^5=3125
         *      
         * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
         * 
         *      4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
         *      
         * How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
         */

        static int Problema29()
        {
            int Resultado = 0;

            List<BigInteger> Lista = CrearLista(2, 100, 2, 100);

            Resultado = Lista.Count();

            return Resultado;
        }

        static List<BigInteger> CrearLista(int minA, int maxA, int minB, int maxB)
        {
            List<BigInteger> Res = new List<BigInteger>();

            for (int a = minA; a <= maxA; a++)
            {
                for (int b = minB; b <= maxB; b++)
                {
                    BigInteger nuevoValor = Exp(a, b);
                    if (!Res.Contains(nuevoValor))
                    {
                        Res.Add(nuevoValor);
                    }
                }
            }


            return Res;
        }


        #endregion

        #endregion

        #region Problemas 30 - 39

        #region Problema 30

        /*
         * Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
         * 
         *          1634 = 1^4 + 6^4 + 3^4 + 4^4
         *          8208 = 8^4 + 2^4 + 0^4 + 8^4
         *          9474 = 9^4 + 4^4 + 7^4 + 4^4
         *          
         * As 1 = 14 is not a sum it is not included.
         * 
         * The sum of these numbers is 1634 + 8208 + 9474 = 19316.
         * 
         * Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
         */

        static BigInteger Problema30()
        {
            BigInteger Resultado = 0;

            List<BigInteger> ListNrosNar = CrearListaNar();

            Resultado = SumaLista(ListNrosNar);

            return Resultado;
        }

        private static List<BigInteger> CrearListaNar()
        {
            List<BigInteger> ListNrosNar = new List<BigInteger>();

            //10 > para que sea una Suma de Digitos.
            //360000 > 6 * 9^5

            for (BigInteger i = 10; i <= 360000; i++)
            {
                BigInteger Suma = SumaDigitos(i, 5);
                if (Suma == i)
                {
                    ListNrosNar.Add(i);
                }
            }
            return ListNrosNar;
        }

        static long SumaExp(List<long> Lista, long Exp)
        {
            long Res = 0;

            for (int i = 0; i < Lista.Count; i++)
            {
                Res += (long)Math.Pow(Lista.ElementAt(i), Exp);
            }

            return Res;
        }

        static BigInteger SumaDigitos(BigInteger Numero)
        {
            BigInteger Res = 0;

            var S_Numero = Numero.ToString();

            var List_S_Numero = S_Numero.ToCharArray().ToList();

            Res = SumaValores(List_S_Numero);



            return Res;
        }

        #endregion

        #region Problema 31

        /*
         * In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:
         * 
         *              1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
         *              
         * It is possible to make £2 in the following way:
         * 
         *              1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
         *              
         * How many different ways can £2 be made using any number of coins?
         */

        static int Problema31()
        {
            int Resultado = 0;

            List<List<int>> Pos = Posibles(200);

            Resultado = Pos.Count();

            return Resultado;
        }

        static int SumaMonedas(List<int> CantidadesMonedas)
        {
            List<int> coin = new List<int> { 200, 100, 50, 20, 10, 5, 2, 1 };

            int Res = 0;

            for (int i = 0; i < CantidadesMonedas.Count; i++)
            {
                Res += CantidadesMonedas.ElementAt(i) * coin.ElementAt(i);
            }


            return Res;
        }

        static List<List<int>> Posibles(int Pence)
        {
            List<List<int>> Res = new List<List<int>>();

            List<int> L_ResTmp = new List<int>();


            for (int l2 = 0; l2 <= Pence; l2 += 200)
            {
                L_ResTmp.Add(l2);
                for (int l1 = l2; l1 <= Pence; l1 += 100)
                {
                    L_ResTmp.Add(l1);
                    for (int p50 = l1; p50 <= Pence; p50 += 50)
                    {
                        L_ResTmp.Add(p50);
                        for (int p20 = p50; p20 <= Pence; p20 += 20)
                        {
                            L_ResTmp.Add(p20);
                            for (int p10 = p20; p10 <= Pence; p10 += 10)
                            {
                                L_ResTmp.Add(p10);
                                for (int p5 = p10; p5 <= Pence; p5 += 5)
                                {
                                    L_ResTmp.Add(p5);
                                    for (int p2 = p5; p2 <= Pence; p2 += 2)
                                    {

                                        L_ResTmp.Add(p2);
                                        //L_ResTmp.AddRange(new List<int> { l2, l1, p50, p20, p10, p5 });

                                        int p1 = Pence - (SumaMonedas(L_ResTmp));
                                        L_ResTmp.Add(p1);

                                        List<int> L_ResTmpTmp = new List<int>();

                                        L_ResTmpTmp.AddRange(L_ResTmp);

                                        //if (!Res.Contains(L_ResTmpTmp) && SumaMonedas(L_ResTmpTmp) == Pence)
                                        //{
                                        Res.Add(L_ResTmpTmp);
                                        //}

                                        L_ResTmp.Remove(p1);


                                        L_ResTmp.Remove(p2);
                                    }
                                    L_ResTmp.Remove(p5);
                                }
                                L_ResTmp.Remove(p10);
                            }
                            L_ResTmp.Remove(p20);
                        }
                        L_ResTmp.Remove(p50);
                    }
                    L_ResTmp.Remove(l1);
                }
                L_ResTmp.Remove(l2);
            }

            return Res;
        }

        #endregion

        #region Problema 32

        /*
         * We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; 
         * for example, the 5-digit number, 15234, is 1 through 5 pandigital.
         * 
         * The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.
         * 
         * Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
         * 
         * HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
         */

        static BigInteger Problema32()
        {
            BigInteger Resultado = 0;

            List<int> ListaEnteros = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

            List<string> ListaPermutaciones = Permutaciones(ListaEnteros);

            ListaPermutaciones.Sort();

            List<int> Productos = ObtenerProductos(ListaPermutaciones);

            Resultado = SumaLista(Productos);

            return Resultado;
        }

        static List<int> ObtenerProductos(List<string> ListaPermutaciones)
        {
            List<int> Res = new List<int>();

            for (int iPerm = 0; iPerm < ListaPermutaciones.Count; iPerm++)
            {
                string TMP = ListaPermutaciones.ElementAt(iPerm);

                List<string[]> Lista = CombProductos(TMP);

                for (int iLista = 0; iLista < Lista.Count; iLista++)
                {
                    string[] as_tmp = Lista.ElementAt(iLista);

                    int Term1 = int.Parse(as_tmp[0]);
                    int Term2 = int.Parse(as_tmp[1]);
                    int Term3 = int.Parse(as_tmp[2]);

                    bool EsProd = (Term1 * Term2) == (Term3);

                    if (EsProd)
                    {
                        if (!Res.Contains(Term3))
                        {
                            Res.Add(Term3);
                        }
                    }
                }

            }



            return Res;
        }

        static List<string[]> CombProductos(string Producto)
        {
            List<string[]> res = new List<string[]>();

            string[] restmp;

            //char[] ac_Producto = Producto.TocharArray();

            for (int CantTerm1 = 1; CantTerm1 <= (Producto.Length) - 2; CantTerm1++)
            {
                for (int CantTerm2 = 1; CantTerm2 <= (Producto.Length) - CantTerm1 - 1; CantTerm2++)
                {
                    int CantTerm3 = Producto.Length - CantTerm1 - CantTerm2;

                    restmp = new string[3];

                    restmp[0] = Producto.Substring(0, CantTerm1);
                    restmp[1] = Producto.Substring(CantTerm1, CantTerm2);
                    restmp[2] = Producto.Substring(CantTerm1 + CantTerm2, CantTerm3);

                    res.Add(restmp);
                }
            }

            return res;
        }

        #endregion

        #region Problema 33

        /*
         * The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, 
         * which is correct, is obtained by cancelling the 9s.
         * 
         * We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
         * 
         * There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.
         * 
         * If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
         */

        static int Problema33()
        {
            int Resultado = 0;

            List<int[]> Facciones = ObtenerFracciones();

            int[] MF = MultipFracciones(Facciones);

            Resultado = BruteForce_mathblog();

            return Resultado;
        }

        static List<int[]> ObtenerFracciones()
        {
            List<int[]> Res = new List<int[]>();

            for (int i = 1; i < 10; i++)
            {
                for (int n = 1; n < 10; n++)
                {
                    for (int d = 1; d < 10; d++)
                    {
                        if (d != n)
                        {

                            double t1;
                            double t2;
                            double t3;

                            t3 = (double)((double)n / (double)d);

                            t1 = (double)(i * 10 + n);
                            t2 = (double)(i * 10 + d);


                            bool Pro1 = t1 / t2 == t3;
                            if (Pro1)
                            {
                                var t = new int[] { (i * 10 + n), (i * 10 + d), i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }

                            // bool Pro2 = (double)((double)(n * 10 + i) / (double)(d * 10 + i)) == (double)(n / d);

                            t1 = (double)(n * 10 + i);
                            t2 = (double)(d * 10 + i);


                            bool Pro2 = t1 / t2 == t3;
                            if (Pro2)
                            {
                                var t = new int[] { (n * 10 + i), (d * 10 + i), i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }

                            //bool Pro3 = (double)((double)(i * 10 + n) / (double)(d * 10 + i)) == (double)(n / d);

                            t1 = (double)(i * 10 + n);
                            t2 = (double)(d * 10 + i);

                            bool Pro3 = t1 / t2 == t3;
                            if (Pro3)
                            {
                                var t = new int[] { (i * 10 + n), (d * 10 + i), i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }

                            // bool Pro4 = (double)((double)(n * 10 + i) / (double)(i * 10 + d)) == (double)(n / d);

                            t1 = (double)(n * 10 + i);
                            t2 = (double)(i * 10 + d);

                            bool Pro4 = t1 / t2 == t3;
                            if (Pro4)
                            {
                                var t = new int[] { (n * 10 + i), (i * 10 + d), i };
                                if (!Res.Contains(t)) Res.Add(t);
                            }
                        }
                    }
                }
            }

            return Res;
        }

        static int[] MultipFracciones(List<int[]> Facciones)
        {
            int[] MulFacciones = new int[2];

            int Numer = 1;
            int Denomi = 1;


            for (int i = 0; i < Facciones.Count; i++)
            {
                Numer *= Facciones.ElementAt(i)[0];
                Denomi *= Facciones.ElementAt(i)[1];
            }

            MulFacciones[0] = Numer;
            MulFacciones[1] = Denomi;


            return MulFacciones;
        }


        static int BruteForce_mathblog()
        {
            int denproduct = 1;
            int nomproduct = 1;

            for (int i = 1; i < 10; i++)
            {
                for (int den = 1; den < i; den++)
                {
                    for (int nom = 1; nom < den; nom++)
                    {
                        if ((nom * 10 + i) * den == nom * (i * 10 + den))
                        {
                            denproduct *= den;
                            nomproduct *= nom;
                        }
                    }
                }
            }

            denproduct /= gcd_mathblog(nomproduct, denproduct);


            // Console.WriteLine("The product of denominators {0}", denproduct);

            return denproduct;
        }

        static private int gcd_mathblog(int a, int b)
        {
            int y, x;

            if (a > b)
            {
                x = a;
                y = b;
            }
            else
            {
                x = b;
                y = a;
            }

            while (x % y != 0)
            {
                int temp = x;
                x = y;
                y = temp % x;
            }

            return y;
        }


        #endregion

        #region Problema 34

        /*
         * 145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
         * 
         * Find the sum of all numbers which are equal to the sum of the factorial of their digits.
         * 
         * Note: as 1! = 1 and 2! = 2 are not sums they are not included.
         */

        static BigInteger Problema34()
        {
            BigInteger Resultado = 0;

            List<int> Numeros = ListaNumerosSumaFact();

            Resultado = SumaLista(Numeros);

            return Resultado;
        }

        static List<int> ListaNumerosSumaFact()
        {
            BigInteger LimiteSup = Factorial(9) * 7; // Factorial(9) * 7 = (7 digitos)   |||   Factorial(9) * 8 = (7 digitos)

            List<int> Fact_0a9 = ListaFact_0a9();

            List<int> Res = new List<int>();

            for (int i = 10; i <= LimiteSup; i++)
            {
                if (i == SumaFactorialDigitos(i, Fact_0a9))
                    Res.Add(i);
            }


            return Res;
        }



        #endregion

        #region Problema 35

        /*
         *The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
         *
         * There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
         * 
         * How many circular primes are there below one million?
         */

        static BigInteger Problema35()
        {
            BigInteger Resultado = 0;

            long Millon = 1000000;
            Resultado = BruteForce(ObtenerPrimos(Millon, false));



            List<long> R = ListaPrimosCirculares(Millon);

            R.Sort();

            R = R.Distinct().ToList();

            Resultado = R.Count;

            return Resultado;

        }

        private static List<long> ListaPrimosCirculares(long Millon)
        {
            List<long> R = new List<long>();
            List<long> NO_R = new List<long>();

            List<long> PrimosBajo = ObtenerPrimos(Millon, false);

            for (int i = 0; i < PrimosBajo.Count; i++)
            {
                long Tmp = PrimosBajo.ElementAt(i);
                if (!R.Contains(Tmp) && !NO_R.Contains(Tmp))
                {
                    List<long> Perm = ListStringToListlong(Permutaciones(ToDigitsList(Tmp)));

                    if (SonPrimos(Perm, PrimosBajo))
                    {
                        R.AddRange(Perm);
                    }
                    else
                    {
                        //NO_R.AddRange(Perm);
                    }
                }
            }
            return R;
        }

        static List<int> ToDigitsList(long Numero)
        {
            List<int> Res = new List<int>();

            var Lis = Numero.ToString().ToCharArray();

            for (int i = 0; i < Lis.Length; i++)
            {
                Res.Add(int.Parse(Lis[i].ToString()));
            }

            return Res;
        }

        static Boolean SonPrimos(List<long> String_Primo, List<long> Primos)
        {
            for (int i = 0; i < String_Primo.Count; i++)
            {
                if (!Primos.Contains(String_Primo.ElementAt(i)))
                    return false;
            }

            return true;
        }

        static List<long> ListStringToListlong(List<string> String_)
        {
            List<long> R = new List<long>();

            for (int i = 0; i < String_.Count; i++)
            {
                R.Add(long.Parse(String_.ElementAt(i)));
            }

            return R;
        }

        static public long CheckCircularPrimes(long prime, List<long> Primos)
        {
            int multiplier = 1;
            long number = prime;
            long count = 0;
            long d;

            //Count the digits and check for even numbers
            while (number > 0)
            {
                d = number % 10;
                if (d % 2 == 0 || d == 5)
                {
                    Primos.Remove(prime);
                    return 0;
                }
                number /= 10;
                multiplier *= 10;
                count++;
            }
            multiplier /= 10;

            //Rotate the number and check if they are prime
            number = prime;
            List<long> foundCircularPrimes = new List<long>();

            for (int i = 0; i < count; i++)
            {
                if (Primos.Contains(number))
                {
                    foundCircularPrimes.Add(number);
                    Primos.Remove(number);
                }
                else if (!foundCircularPrimes.Contains(number))
                {
                    return 0;
                }

                d = number % 10;
                number = d * multiplier + number / 10;
            }

            return foundCircularPrimes.Count;
        }

        static public long BruteForce(List<long> Primos)
        {


            long noCircularPrimes = 2;

            //Special cases
            Primos.Remove(2);
            Primos.Remove(5);

            while (Primos.Count > 0)
            {
                noCircularPrimes += CheckCircularPrimes(Primos.Min(), Primos);
            }

            return noCircularPrimes;
        }


        #endregion

        #endregion

        #region Problema 67

        /*
         * By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
         *
         *                                     3
         *                                    7 4
         *                                   2 4 6
         *                                  8 5 9 3
         *
         *  That is, 3 + 7 + 4 + 9 = 23.
         *  
         * Find the maximum total from top to bottom in triangle.txt (right click and 'Save Link/Target As...'), a 15K text file containing a triangle with one-hundred rows.
         * 
         * NOTE: This is a much more difficult version of Problem 18. It is not possible to try every route to solve this problem, as there are 299 altogether!
         * If you could check one trillion (1012) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it. ;o)
         */

        static long Problema64()
        {
            long Resultado = 0;

            List<List<string>> ListaNumeros_S = LeerArchivo("Archivos\\Triangulo2.txt");

            Resultado = CalcMax(ListaNumeros_S);

            return Resultado;
        }

        #endregion

        #region Extras

        static string RemoveChars(this string value, params char[] charsRemove)
        {
            foreach (var charRemove in charsRemove)
            {
                value.Replace(charRemove.ToString(), "");
            }

            return value;
        }

        static char ToLower(this char value) => char.ToLower(value, new System.Globalization.CultureInfo("es-AR", false));

        static char ToUpper(this char value) => char.ToUpper(value, new System.Globalization.CultureInfo("es-AR", false));

        #endregion
    }
}
